Index: 5_2_4/ext/standard/dir.c
===================================================================
--- 5_2_4.orig/ext/standard/dir.c
+++ 5_2_4/ext/standard/dir.c
@@ -396,11 +396,17 @@ PHP_FUNCTION(glob)
 	glob_t globbuf;
 	int n;
 	int ret;
+	zend_bool basedir_limit = 0;
 
 	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "s|l", &pattern, &pattern_len, &flags) == FAILURE) {
 		return;
 	}
 
+	if (pattern_len >= MAXPATHLEN) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Pattern exceeds the maximum allowed length of %d characters", MAXPATHLEN);
+		RETURN_FALSE;
+	}
+
 	if ((GLOB_AVAILABLE_FLAGS & flags) != flags) {
 		php_error_docref(NULL TSRMLS_CC, E_WARNING, "At least one of the passed flags is invalid or not supported on this platform");
 		RETURN_FALSE;
@@ -424,22 +430,6 @@ PHP_FUNCTION(glob)
 	} 
 #endif
 
-	if (PG(safe_mode) || (PG(open_basedir) && *PG(open_basedir))) {
-		int pattern_len = strlen(pattern);
-		char *basename = estrndup(pattern, pattern_len);
-		
-		php_dirname(basename, pattern_len);
-		if (PG(safe_mode) && (!php_checkuid(basename, NULL, CHECKUID_CHECK_FILE_AND_DIR))) {
-			efree(basename);
-			RETURN_FALSE;
-		}
-		if (php_check_open_basedir(basename TSRMLS_CC)) {
-			efree(basename);
-			RETURN_FALSE;
-		}
-		efree(basename);
-	}
-
 	memset(&globbuf, 0, sizeof(glob_t));
 	globbuf.gl_offs = 0;
 	if (0 != (ret = glob(pattern, flags & GLOB_FLAGMASK, NULL, &globbuf))) {
@@ -453,8 +443,7 @@ PHP_FUNCTION(glob)
 			   can be used for simple glob() calls without further error
 			   checking.
 			*/
-			array_init(return_value);
-			return;
+			goto no_results;
 		}
 #endif
 		RETURN_FALSE;
@@ -462,12 +451,29 @@ PHP_FUNCTION(glob)
 
 	/* now catch the FreeBSD style of "no matches" */
 	if (!globbuf.gl_pathc || !globbuf.gl_pathv) {
+no_results:
+		if (PG(safe_mode) || (PG(open_basedir) && *PG(open_basedir))) {
+			struct stat s;
+
+			if (0 != VCWD_STAT(pattern, &s) || S_IFDIR != (s.st_mode & S_IFMT)) {
+				RETURN_FALSE;
+			}
+		}
 		array_init(return_value);
 		return;
 	}
 
 	array_init(return_value);
 	for (n = 0; n < globbuf.gl_pathc; n++) {
+		if (PG(safe_mode) || (PG(open_basedir) && *PG(open_basedir))) {
+			if (PG(safe_mode) && (!php_checkuid(globbuf.gl_pathv[n], NULL, CHECKUID_CHECK_FILE_AND_DIR))) {
+				basedir_limit = 1;
+				continue;
+			} else if (php_check_open_basedir_ex(globbuf.gl_pathv[n], 0 TSRMLS_CC)) {
+				basedir_limit = 1;
+				continue;
+			}
+		}
 		/* we need to do this everytime since GLOB_ONLYDIR does not guarantee that
 		 * all directories will be filtered. GNU libc documentation states the
 		 * following: 
@@ -491,6 +497,11 @@ PHP_FUNCTION(glob)
 	}
 
 	globfree(&globbuf);
+
+	if (basedir_limit && !zend_hash_num_elements(Z_ARRVAL_P(return_value))) {
+		zval_dtor(return_value);
+		RETURN_FALSE;
+	}
 }
 /* }}} */
 #endif 
Index: 5_2_4/ext/standard/tests/file/bug41655_1.phpt
===================================================================
--- 5_2_4.orig/ext/standard/tests/file/bug41655_1.phpt
+++ 5_2_4/ext/standard/tests/file/bug41655_1.phpt
@@ -1,10 +1,12 @@
 --TEST--
-Bug #41655 (open_basedir bypass via glob())
+Bug #41655 (open_basedir bypass via glob()) 1/2
 --INI--
 open_basedir=/tmp
 --FILE--
 <?php
 	$a=glob("./*.jpeg");
+
+echo "Done\n";
 ?>
---EXPECTF--
-Warning: glob(): open_basedir restriction in effect. File%s.) is not within the allowed path(s): (/tmp) in %s on line %d
+--EXPECT--
+Done
\ No newline at end of file
Index: 5_2_4/ext/standard/tests/file/bug41655_2.phpt
===================================================================
--- 5_2_4.orig/ext/standard/tests/file/bug41655_2.phpt
+++ 5_2_4/ext/standard/tests/file/bug41655_2.phpt
@@ -1,5 +1,5 @@
 --TEST--
-Bug #41655: open_basedir bypass via glob()
+Bug #41655 (open_basedir bypass via glob()) 2/2
 --INI--
 open_basedir=/
 --FILE--
@@ -11,6 +11,7 @@ open_basedir=/
 --EXPECTF--
 Array
 (
-    [%d] => %sbug41655_1.phpt
-    [%d] => %sbug41655_2.phpt
+    [0] => %sbug41655_1.phpt
+    [1] => %sbug41655_2.php
+    [2] => %sbug41655_2.phpt
 )
Index: 5_2_4/main/main.c
===================================================================
--- 5_2_4.orig/main/main.c
+++ 5_2_4/main/main.c
@@ -318,6 +318,18 @@ static PHP_INI_MH(OnUpdateErrorLog)
 }
 /* }}} */
 
+/* {{{ PHP_INI_MH
+*/
+static PHP_INI_MH(OnChangeMailForceExtra)
+{
+	/* Don't allow changing it in htaccess */
+	if (stage == PHP_INI_STAGE_HTACCESS) {
+		return FAILURE;
+	}
+	return SUCCESS;
+}
+/* }}} */
+
 /* Need to convert to strings and make use of:
  * PHP_SAFE_MODE
  *
@@ -428,7 +440,7 @@ PHP_INI_BEGIN()
 	PHP_INI_ENTRY("precision",					"14",		PHP_INI_ALL,		OnSetPrecision)
 	PHP_INI_ENTRY("sendmail_from",				NULL,		PHP_INI_ALL,		NULL)
 	PHP_INI_ENTRY("sendmail_path",	DEFAULT_SENDMAIL_PATH,	PHP_INI_SYSTEM,		NULL)
-	PHP_INI_ENTRY("mail.force_extra_parameters",NULL,		PHP_INI_SYSTEM|PHP_INI_PERDIR,		NULL)
+	PHP_INI_ENTRY("mail.force_extra_parameters",NULL,		PHP_INI_SYSTEM|PHP_INI_PERDIR,		OnChangeMailForceExtra)
 	PHP_INI_ENTRY("disable_functions",			"",			PHP_INI_SYSTEM,		NULL)
 	PHP_INI_ENTRY("disable_classes",			"",			PHP_INI_SYSTEM,		NULL)
 
Index: 5_2_4/ext/pdo/pdo_stmt.c
===================================================================
--- 5_2_4.orig/ext/pdo/pdo_stmt.c
+++ 5_2_4/ext/pdo/pdo_stmt.c
@@ -545,7 +545,11 @@ static inline void fetch_value(pdo_stmt_
 					char *buf = NULL;
 					size_t len;
 					len = php_stream_copy_to_mem((php_stream*)value, &buf, PHP_STREAM_COPY_ALL, 0);
-					ZVAL_STRINGL(dest, buf, len, 0);
+					if(buf == NULL) {
+						ZVAL_EMPTY_STRING(dest);
+					} else {
+						ZVAL_STRINGL(dest, buf, len, 0);
+					}
 					php_stream_close((php_stream*)value);
 				} else {
 					php_stream_to_zval((php_stream*)value, dest);
Index: 5_2_4/ext/standard/dl.c
===================================================================
--- 5_2_4.orig/ext/standard/dl.c
+++ 5_2_4/ext/standard/dl.c
@@ -84,6 +84,11 @@ PHP_FUNCTION(dl)
 #endif
 	}
 
+	if (Z_STRLEN_PP(file) >= MAXPATHLEN) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "File name exceeds the maximum allowed length of %d characters", MAXPATHLEN);
+		RETURN_FALSE;
+	}
+
 	php_dl(*file, MODULE_TEMPORARY, return_value, 0 TSRMLS_CC);
 	EG(full_tables_cleanup) = 1;
 }
@@ -125,6 +130,13 @@ void php_dl(zval *file, int type, zval *
 	if (extension_dir && extension_dir[0]){
 		int extension_dir_len = strlen(extension_dir);
 
+		if(type == MODULE_TEMPORARY) {
+			if(strchr(Z_STRVAL_P(file), '/') != NULL || strchr(Z_STRVAL_P(file), DEFAULT_SLASH) != NULL) {
+				php_error_docref(NULL TSRMLS_CC, E_WARNING, "Temporary module name should contain only filename");
+				RETURN_FALSE;
+			}
+		}
+
 		if (IS_SLASH(extension_dir[extension_dir_len-1])) {
 			spprintf(&libpath, 0, "%s%s", extension_dir, Z_STRVAL_P(file));
 		} else {
Index: 5_2_4/ext/iconv/iconv.c
===================================================================
--- 5_2_4.orig/ext/iconv/iconv.c
+++ 5_2_4/ext/iconv/iconv.c
@@ -233,12 +233,21 @@ static char _generic_superset_name[] = "
 #define GENERIC_SUPERSET_NBYTES 4
 /* }}} */
 
+static PHP_INI_MH(OnUpdateStringIconvCharset)
+{
+	if(new_value_length >= ICONV_CSNMAXLEN) {
+		return FAILURE;
+	}
+	OnUpdateString(entry, new_value, new_value_length, mh_arg1, mh_arg2, mh_arg3, stage TSRMLS_CC);
+	return SUCCESS;
+}
+
 /* {{{ PHP_INI
  */
 PHP_INI_BEGIN()
-	STD_PHP_INI_ENTRY("iconv.input_encoding",    ICONV_INPUT_ENCODING,    PHP_INI_ALL, OnUpdateString, input_encoding,    zend_iconv_globals, iconv_globals)
-	STD_PHP_INI_ENTRY("iconv.output_encoding",   ICONV_OUTPUT_ENCODING,   PHP_INI_ALL, OnUpdateString, output_encoding,   zend_iconv_globals, iconv_globals)
-	STD_PHP_INI_ENTRY("iconv.internal_encoding", ICONV_INTERNAL_ENCODING, PHP_INI_ALL, OnUpdateString, internal_encoding, zend_iconv_globals, iconv_globals)
+	STD_PHP_INI_ENTRY("iconv.input_encoding",    ICONV_INPUT_ENCODING,    PHP_INI_ALL, OnUpdateStringIconvCharset, input_encoding,    zend_iconv_globals, iconv_globals)
+	STD_PHP_INI_ENTRY("iconv.output_encoding",   ICONV_OUTPUT_ENCODING,   PHP_INI_ALL, OnUpdateStringIconvCharset, output_encoding,   zend_iconv_globals, iconv_globals)
+	STD_PHP_INI_ENTRY("iconv.internal_encoding", ICONV_INTERNAL_ENCODING, PHP_INI_ALL, OnUpdateStringIconvCharset, internal_encoding, zend_iconv_globals, iconv_globals)
 PHP_INI_END()
 /* }}} */
 
@@ -691,11 +700,15 @@ static php_iconv_err_t _php_iconv_substr
 		}
 	}
 
-	if (offset >= total_len) {
+	if (len > total_len) {
+		len = total_len;
+	}
+
+	if (offset > total_len) {
 		return PHP_ICONV_ERR_SUCCESS;
 	}
 
-	if ((offset + len) > total_len) {
+	if ((offset + len) > total_len ) {
 		/* trying to compute the length */
 		len = total_len - offset;
 	}
@@ -1023,7 +1036,7 @@ static php_iconv_err_t _php_iconv_mime_e
 		goto out;
 	}
 
-	cd_pl = iconv_open("ASCII", enc);
+	cd_pl = iconv_open(ICONV_ASCII_ENCODING, enc);
 	if (cd_pl == (iconv_t)(-1)) {
 #if ICONV_SUPPORTS_ERRNO
 		if (errno == EINVAL) {
@@ -1334,7 +1347,7 @@ static php_iconv_err_t _php_iconv_mime_d
 		*next_pos = NULL;
 	}
 
-	cd_pl = iconv_open(enc, "ASCII");
+	cd_pl = iconv_open(enc, ICONV_ASCII_ENCODING);
 
 	if (cd_pl == (iconv_t)(-1)) {
 #if ICONV_SUPPORTS_ERRNO
@@ -1858,7 +1871,7 @@ static void _php_iconv_show_error(php_ic
 PHP_FUNCTION(iconv_strlen)
 {
 	char *charset;
-	int charset_len;
+	int charset_len = 0;
 	char *str;
 	int str_len; 
 
@@ -1873,6 +1886,11 @@ PHP_FUNCTION(iconv_strlen)
 		RETURN_FALSE;
 	}
 
+	if (charset_len >= ICONV_CSNMAXLEN) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Charset parameter exceeds the maximum allowed length of %d characters", ICONV_CSNMAXLEN);
+		RETURN_FALSE;
+	}
+
 	err = _php_iconv_strlen(&retval, str, str_len, charset); 
 	_php_iconv_show_error(err, GENERIC_SUPERSET_NAME, charset TSRMLS_CC);
 	if (err == PHP_ICONV_ERR_SUCCESS) {
@@ -1888,7 +1906,7 @@ PHP_FUNCTION(iconv_strlen)
 PHP_FUNCTION(iconv_substr)
 {
 	char *charset;
-	int charset_len;
+	int charset_len = 0;
 	char *str;
 	int str_len; 
 	long offset, length;
@@ -1905,6 +1923,11 @@ PHP_FUNCTION(iconv_substr)
 		RETURN_FALSE;
 	}
 
+	if (charset_len >= ICONV_CSNMAXLEN) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Charset parameter exceeds the maximum allowed length of %d characters", ICONV_CSNMAXLEN);
+		RETURN_FALSE;
+	}
+
 	if (ZEND_NUM_ARGS() < 3) {
 		length = str_len; 
 	}
@@ -1925,7 +1948,7 @@ PHP_FUNCTION(iconv_substr)
 PHP_FUNCTION(iconv_strpos)
 {
 	char *charset;
-	int charset_len;
+	int charset_len = 0;
 	char *haystk;
 	int haystk_len; 
 	char *ndl;
@@ -1945,6 +1968,11 @@ PHP_FUNCTION(iconv_strpos)
 		RETURN_FALSE;
 	}
 
+	if (charset_len >= ICONV_CSNMAXLEN) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Charset parameter exceeds the maximum allowed length of %d characters", ICONV_CSNMAXLEN);
+		RETURN_FALSE;
+	}
+
 	if (offset < 0) {
 		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Offset not contained in string.");
 		RETURN_FALSE;
@@ -1971,7 +1999,7 @@ PHP_FUNCTION(iconv_strpos)
 PHP_FUNCTION(iconv_strrpos)
 {
 	char *charset;
-	int charset_len;
+	int charset_len = 0;
 	char *haystk;
 	int haystk_len; 
 	char *ndl;
@@ -1989,6 +2017,11 @@ PHP_FUNCTION(iconv_strrpos)
 		RETURN_FALSE;
 	}
 
+	if (charset_len >= ICONV_CSNMAXLEN) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Charset parameter exceeds the maximum allowed length of %d characters", ICONV_CSNMAXLEN);
+		RETURN_FALSE;
+	}
+
 	if (ndl_len < 1) {
 		RETURN_FALSE;
 	}
@@ -2049,6 +2082,11 @@ PHP_FUNCTION(iconv_mime_encode)
 		}
 
 		if (zend_hash_find(Z_ARRVAL_P(pref), "input-charset", sizeof("input-charset"), (void **)&ppval) == SUCCESS) {
+			if (Z_STRLEN_PP(ppval) >= ICONV_CSNMAXLEN) {
+				php_error_docref(NULL TSRMLS_CC, E_WARNING, "Charset parameter exceeds the maximum allowed length of %d characters", ICONV_CSNMAXLEN);
+				RETURN_FALSE;
+			}
+
 			if (Z_TYPE_PP(ppval) == IS_STRING && Z_STRLEN_PP(ppval) > 0) {
 				in_charset = Z_STRVAL_PP(ppval);
 			}
@@ -2056,6 +2094,11 @@ PHP_FUNCTION(iconv_mime_encode)
 
 
 		if (zend_hash_find(Z_ARRVAL_P(pref), "output-charset", sizeof("output-charset"), (void **)&ppval) == SUCCESS) {
+			if (Z_STRLEN_PP(ppval) >= ICONV_CSNMAXLEN) {
+				php_error_docref(NULL TSRMLS_CC, E_WARNING, "Charset parameter exceeds the maximum allowed length of %d characters", ICONV_CSNMAXLEN);
+				RETURN_FALSE;
+			}
+
 			if (Z_TYPE_PP(ppval) == IS_STRING && Z_STRLEN_PP(ppval) > 0) {
 				out_charset = Z_STRVAL_PP(ppval);
 			}
@@ -2122,7 +2165,7 @@ PHP_FUNCTION(iconv_mime_decode)
 	char *encoded_str;
 	int encoded_str_len;
 	char *charset;
-	int charset_len;
+	int charset_len = 0;
 	long mode = 0;
 	
 	smart_str retval = {0};
@@ -2137,6 +2180,11 @@ PHP_FUNCTION(iconv_mime_decode)
 		RETURN_FALSE;
 	}
 
+	if (charset_len >= ICONV_CSNMAXLEN) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Charset parameter exceeds the maximum allowed length of %d characters", ICONV_CSNMAXLEN);
+		RETURN_FALSE;
+	}
+
 	err = _php_iconv_mime_decode(&retval, encoded_str, encoded_str_len, charset, NULL, mode);
 	_php_iconv_show_error(err, charset, "???" TSRMLS_CC);
 
@@ -2160,7 +2208,7 @@ PHP_FUNCTION(iconv_mime_decode_headers)
 	const char *encoded_str;
 	int encoded_str_len;
 	char *charset;
-	int charset_len;
+	int charset_len = 0;
 	long mode = 0;
 	
 	php_iconv_err_t err = PHP_ICONV_ERR_SUCCESS;
@@ -2173,6 +2221,11 @@ PHP_FUNCTION(iconv_mime_decode_headers)
 		RETURN_FALSE;
 	}
 
+	if (charset_len >= ICONV_CSNMAXLEN) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Charset parameter exceeds the maximum allowed length of %d characters", ICONV_CSNMAXLEN);
+		RETURN_FALSE;
+	}
+
 	array_init(return_value);
 
 	while (encoded_str_len > 0) {
@@ -2255,13 +2308,18 @@ PHP_NAMED_FUNCTION(php_if_iconv)
 {
 	char *in_charset, *out_charset, *in_buffer, *out_buffer;
 	size_t out_len;
-	int in_charset_len, out_charset_len, in_buffer_len;
+	int in_charset_len = 0, out_charset_len = 0, in_buffer_len;
 	php_iconv_err_t err;
 	
 	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "sss",
 		&in_charset, &in_charset_len, &out_charset, &out_charset_len, &in_buffer, &in_buffer_len) == FAILURE)
 		return;
 
+	if (in_charset_len >= ICONV_CSNMAXLEN || out_charset_len >= ICONV_CSNMAXLEN) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Charset parameter exceeds the maximum allowed length of %d characters", ICONV_CSNMAXLEN);
+		RETURN_FALSE;
+	}
+
 	err = php_iconv_string(in_buffer, (size_t)in_buffer_len,
 		&out_buffer, &out_len, out_charset, in_charset);
 	_php_iconv_show_error(err, out_charset, in_charset TSRMLS_CC); 
@@ -2330,11 +2388,16 @@ PHP_FUNCTION(ob_iconv_handler)
 PHP_FUNCTION(iconv_set_encoding)
 {
 	char *type, *charset;
-	int type_len, charset_len, retval;
+	int type_len, charset_len = 0, retval;
 
 	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "ss", &type, &type_len, &charset, &charset_len) == FAILURE)
 		return;
 
+	if (charset_len >= ICONV_CSNMAXLEN) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Charset parameter exceeds the maximum allowed length of %d characters", ICONV_CSNMAXLEN);
+		RETURN_FALSE;
+	}
+
 	if(!strcasecmp("input_encoding", type)) {
 		retval = zend_alter_ini_entry("iconv.input_encoding", sizeof("iconv.input_encoding"), charset, charset_len, PHP_INI_USER, PHP_INI_STAGE_RUNTIME);
 	} else if(!strcasecmp("output_encoding", type)) {
@@ -2726,6 +2789,10 @@ static php_stream_filter *php_iconv_stre
 	++to_charset;
 	to_charset_len = strlen(to_charset);
 
+	if (from_charset_len >= ICONV_CSNMAXLEN || to_charset_len >= ICONV_CSNMAXLEN) {
+		return NULL;
+	}
+
 	if (NULL == (inst = pemalloc(sizeof(php_iconv_stream_filter), persistent))) {
 		return NULL;
 	}
Index: 5_2_4/ext/iconv/php_iconv.h
===================================================================
--- 5_2_4.orig/ext/iconv/php_iconv.h
+++ 5_2_4/ext/iconv/php_iconv.h
@@ -37,6 +37,7 @@
 #include "ext/iconv/php_have_libiconv.h"
 #include "ext/iconv/php_have_glibc_iconv.h"
 #include "ext/iconv/php_have_bsd_iconv.h"
+#include "ext/iconv/php_have_ibm_iconv.h"
 #include "ext/iconv/php_iconv_supports_errno.h"
 #include "ext/iconv/php_php_iconv_impl.h"
 #include "ext/iconv/php_php_iconv_h_path.h"
@@ -75,9 +76,21 @@ ZEND_END_MODULE_GLOBALS(iconv)
 #define ICONVG(v) (iconv_globals.v)
 #endif
 
-#define ICONV_INPUT_ENCODING "ISO-8859-1" 
-#define ICONV_OUTPUT_ENCODING "ISO-8859-1"
-#define ICONV_INTERNAL_ENCODING "ISO-8859-1" 
+#ifdef HAVE_IBM_ICONV
+# define ICONV_INPUT_ENCODING "ISO8859-1"
+# define ICONV_OUTPUT_ENCODING "ISO8859-1"
+# define ICONV_INTERNAL_ENCODING "ISO8859-1"
+# define ICONV_ASCII_ENCODING "IBM-850"
+#else
+# define ICONV_INPUT_ENCODING "ISO-8859-1"
+# define ICONV_OUTPUT_ENCODING "ISO-8859-1"
+# define ICONV_INTERNAL_ENCODING "ISO-8859-1"
+# define ICONV_ASCII_ENCODING "ASCII"
+#endif
+
+#ifndef ICONV_CSNMAXLEN
+#define ICONV_CSNMAXLEN 64
+#endif
 
 /* {{{ typedef enum php_iconv_err_t */
 typedef enum _php_iconv_err_t {
Index: 5_2_4/ext/standard/file.c
===================================================================
--- 5_2_4.orig/ext/standard/file.c
+++ 5_2_4/ext/standard/file.c
@@ -2517,7 +2517,12 @@ PHP_FUNCTION(fnmatch)
 							  &flags) 
 		== FAILURE) 
 		return;
-	
+
+	if (filename_len >= MAXPATHLEN) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Filename exceeds the maximum allowed length of %d characters", MAXPATHLEN);
+		RETURN_FALSE;
+	}
+
 	RETURN_BOOL( ! fnmatch( pattern, filename, flags ));
 }
 /* }}} */
Index: 5_2_4/ext/standard/string.c
===================================================================
--- 5_2_4.orig/ext/standard/string.c
+++ 5_2_4/ext/standard/string.c
@@ -4000,6 +4000,10 @@ PHP_FUNCTION(setlocale)
 			loc = NULL;
 		} else {
 			loc = Z_STRVAL_PP(plocale);
+			if (Z_STRLEN_PP(plocale) >= 255) {
+				php_error_docref(NULL TSRMLS_CC, E_WARNING, "Specified locale name is too long");
+				break;
+			}
 		}
 		
 		retval = setlocale (cat, loc);
Index: 5_2_4/ext/dom/php_dom.c
===================================================================
--- 5_2_4.orig/ext/dom/php_dom.c
+++ 5_2_4/ext/dom/php_dom.c
@@ -943,6 +943,7 @@ void node_list_unlink(xmlNodePtr node TS
 				case XML_DOCUMENT_TYPE_NODE:
 				case XML_ENTITY_DECL:
 				case XML_ATTRIBUTE_NODE:
+				case XML_TEXT_NODE:
 					break;
 				default:
 					node_list_unlink((xmlNodePtr) node->properties TSRMLS_CC);
Index: 5_2_4/ext/soap/php_encoding.c
===================================================================
--- 5_2_4.orig/ext/soap/php_encoding.c
+++ 5_2_4/ext/soap/php_encoding.c
@@ -357,7 +357,7 @@ static zend_bool soap_check_xml_ref(zval
 	return 0;
 }
 
-xmlNodePtr master_to_xml(encodePtr encode, zval *data, int style, xmlNodePtr parent)
+static xmlNodePtr master_to_xml_int(encodePtr encode, zval *data, int style, xmlNodePtr parent, int check_class_map)
 {
 	xmlNodePtr node = NULL;
 	TSRMLS_FETCH();
@@ -428,7 +428,7 @@ xmlNodePtr master_to_xml(encodePtr encod
 			xmlSetNs(node, nsp);
 		}
 	} else {
-		if (SOAP_GLOBAL(class_map) && data &&
+		if (check_class_map && SOAP_GLOBAL(class_map) && data &&
 		    Z_TYPE_P(data) == IS_OBJECT &&
 		    !Z_OBJPROP_P(data)->nApplyCount) {
 			zend_class_entry *ce = Z_OBJCE_P(data);
@@ -489,6 +489,11 @@ xmlNodePtr master_to_xml(encodePtr encod
 	return node;
 }
 
+xmlNodePtr master_to_xml(encodePtr encode, zval *data, int style, xmlNodePtr parent)
+{
+	return master_to_xml_int(encode, data, style, parent, 1);
+}
+
 static zval *master_to_zval_int(encodePtr encode, xmlNodePtr data)
 {
 	zval *ret = NULL;
@@ -859,13 +864,50 @@ static xmlNodePtr to_xml_string(encodeTy
 			efree(str);
 			str = estrdup((char*)xmlBufferContent(out));
 			new_len = n;
-		} else if (!php_libxml_xmlCheckUTF8(BAD_CAST(str))) {
-			soap_error1(E_ERROR,  "Encoding: string '%s' is not a valid utf-8 string", str);
 		}
 		xmlBufferFree(out);
 		xmlBufferFree(in);
-	} else if (!php_libxml_xmlCheckUTF8(BAD_CAST(str))) {
-		soap_error1(E_ERROR,  "Encoding: string '%s' is not a valid utf-8 string", str);
+	}
+
+	if (!php_libxml_xmlCheckUTF8(BAD_CAST(str))) {
+		char *err = emalloc(new_len + 8);
+		char c;
+		int i;
+
+		memcpy(err, str, new_len+1);
+		for (i = 0; (c = err[i++]);) {
+			if ((c & 0x80) == 0) {
+			} else if ((c & 0xe0) == 0xc0) {
+				if ((err[i] & 0xc0) != 0x80) {
+					break;
+				}
+				i++;
+			} else if ((c & 0xf0) == 0xe0) {
+				if ((err[i] & 0xc0) != 0x80 || (err[i+1] & 0xc0) != 0x80) {
+					break;
+				}
+				i += 2;
+			} else if ((c & 0xf8) == 0xf0) {
+				if ((err[i] & 0xc0) != 0x80 || (err[i+1] & 0xc0) != 0x80 || (err[i+2] & 0xc0) != 0x80) {
+					break;
+				}
+				i += 3;
+			} else {
+				break;
+			}
+		}
+		if (c) {
+			err[i-1] = '\\';
+			err[i++] = 'x';
+			err[i++] = ((unsigned char)c >> 4) + ((((unsigned char)c >> 4) > 9) ? ('a' - 10) : '0');
+			err[i++] = (c & 15) + (((c & 15) > 9) ? ('a' - 10) : '0');
+			err[i++] = '.';
+			err[i++] = '.';
+			err[i++] = '.';
+			err[i++] = 0;
+		}
+
+		soap_error1(E_ERROR,  "Encoding: string '%s' is not a valid utf-8 string", err);
 	}
 
 	text = xmlNewTextLen(BAD_CAST(str), new_len);
@@ -2685,7 +2727,7 @@ static xmlNodePtr guess_xml_convert(enco
 	} else {
 		enc = get_conversion(IS_NULL);
 	}
-	ret = master_to_xml(enc, data, style, parent);
+	ret = master_to_xml_int(enc, data, style, parent, 0);
 /*
 	if (style == SOAP_LITERAL && SOAP_GLOBAL(sdl)) {
 		set_ns_and_type(ret, &enc->details);
Index: 5_2_4/ext/soap/php_soap.h
===================================================================
--- 5_2_4.orig/ext/soap/php_soap.h
+++ 5_2_4/ext/soap/php_soap.h
@@ -106,6 +106,7 @@ struct _soapService {
 	HashTable *class_map;
 	int        features;
 	struct _soapHeader **soap_headers_ptr;
+	int send_errors;
 };
 
 #define SOAP_CLASS 1
Index: 5_2_4/ext/soap/soap.c
===================================================================
--- 5_2_4.orig/ext/soap/soap.c
+++ 5_2_4/ext/soap/soap.c
@@ -1035,6 +1035,7 @@ PHP_METHOD(SoapServer, SoapServer)
 
 	service = emalloc(sizeof(soapService));
 	memset(service, 0, sizeof(soapService));
+	service->send_errors = 1;
 
 	cache_wsdl = SOAP_GLOBAL(cache);
 
@@ -1099,6 +1100,10 @@ PHP_METHOD(SoapServer, SoapServer)
 			cache_wsdl = Z_LVAL_PP(tmp);
 		}
 
+		if (zend_hash_find(ht, "send_errors", sizeof("send_errors"), (void**)&tmp) == SUCCESS &&
+				(Z_TYPE_PP(tmp) == IS_BOOL || Z_TYPE_PP(tmp) == IS_LONG)) {
+			service->send_errors = Z_LVAL_PP(tmp);
+		}
 	} else if (wsdl == NULL) {
 		php_error_docref(NULL TSRMLS_CC, E_ERROR, "Invalid arguments. 'uri' option is required in nonWSDL mode.");
 	}
@@ -2129,34 +2134,47 @@ static void soap_error_handler(int error
 
 			char* code = SOAP_GLOBAL(error_code);
 			char buffer[1024];
-			int buffer_len;
 			zval *outbuf = NULL;
-			zval outbuflen;
+			zval **tmp;
+			soapServicePtr service;
+
+
+			if (code == NULL) {
+				code = "Server";
+			}
+			if (SOAP_GLOBAL(error_object) &&
+					Z_TYPE_P(SOAP_GLOBAL(error_object)) == IS_OBJECT &&
+					instanceof_function(Z_OBJCE_P(SOAP_GLOBAL(error_object)), soap_server_class_entry TSRMLS_CC) &&
+					zend_hash_find(Z_OBJPROP_P(SOAP_GLOBAL(error_object)), "service", sizeof("service"), (void **)&tmp) != FAILURE &&
+					(service = (soapServicePtr)zend_fetch_resource(tmp TSRMLS_CC, -1, "service", NULL, 1, le_service)) &&
+					!service->send_errors) {
+				strcpy(buffer, "Internal Error");
+			} else {
+				int buffer_len;
+				zval outbuflen;
+
+				INIT_ZVAL(outbuflen);
 
-			INIT_ZVAL(outbuflen);
 
 #ifdef va_copy
-			va_copy(argcopy, args);
-			buffer_len = vslprintf(buffer, sizeof(buffer)-1, format, argcopy);
-			va_end(argcopy);
+				va_copy(argcopy, args);
+				buffer_len = vslprintf(buffer, sizeof(buffer)-1, format, argcopy);
+				va_end(argcopy);
 #else
-			buffer_len = vslprintf(buffer, sizeof(buffer)-1, format, args);
+				buffer_len = vslprintf(buffer, sizeof(buffer)-1, format, args);
 #endif
-			buffer[sizeof(buffer)-1]=0;
-			if (buffer_len > sizeof(buffer) - 1 || buffer_len < 0) {
-				buffer_len = sizeof(buffer) - 1;
-			}
+				buffer[sizeof(buffer)-1]=0;
+				if (buffer_len > sizeof(buffer) - 1 || buffer_len < 0) {
+					buffer_len = sizeof(buffer) - 1;
+				}
 
-			if (code == NULL) {
-				code = "Server";
-			}
-			/* Get output buffer and send as fault detials */
-			if (php_ob_get_length(&outbuflen TSRMLS_CC) != FAILURE && Z_LVAL(outbuflen) != 0) {
-				ALLOC_INIT_ZVAL(outbuf);
-		    php_ob_get_buffer(outbuf TSRMLS_CC);
+				/* Get output buffer and send as fault detials */
+				if (php_ob_get_length(&outbuflen TSRMLS_CC) != FAILURE && Z_LVAL(outbuflen) != 0) {
+					ALLOC_INIT_ZVAL(outbuf);
+					php_ob_get_buffer(outbuf TSRMLS_CC);
+				}
+				php_end_ob_buffer(0, 0 TSRMLS_CC);
 			}
-			php_end_ob_buffer(0, 0 TSRMLS_CC);
-
 			INIT_ZVAL(fault_obj);
 			set_soap_fault(&fault_obj, NULL, code, buffer, NULL, outbuf, NULL TSRMLS_CC);
 			fault = 1;
Index: 5_2_4/ext/xmlrpc/libxmlrpc/xmlrpc.c
===================================================================
--- 5_2_4.orig/ext/xmlrpc/libxmlrpc/xmlrpc.c
+++ 5_2_4/ext/xmlrpc/libxmlrpc/xmlrpc.c
@@ -186,15 +186,19 @@ static int date_from_ISO8601 (const char
       return -1;
    }
 
+#define XMLRPC_IS_NUMBER(x) if (x < '0' || x > '9') return -1;
+
    n = 1000;
    tm.tm_year = 0;
    for(i = 0; i < 4; i++) {
+      XMLRPC_IS_NUMBER(text[i]);
       tm.tm_year += (text[i]-'0')*n;
       n /= 10;
    }
    n = 10;
    tm.tm_mon = 0;
    for(i = 0; i < 2; i++) {
+      XMLRPC_IS_NUMBER(text[i]);
       tm.tm_mon += (text[i+4]-'0')*n;
       n /= 10;
    }
@@ -203,6 +207,7 @@ static int date_from_ISO8601 (const char
    n = 10;
    tm.tm_mday = 0;
    for(i = 0; i < 2; i++) {
+      XMLRPC_IS_NUMBER(text[i]);
       tm.tm_mday += (text[i+6]-'0')*n;
       n /= 10;
    }
@@ -210,6 +215,7 @@ static int date_from_ISO8601 (const char
    n = 10;
    tm.tm_hour = 0;
    for(i = 0; i < 2; i++) {
+      XMLRPC_IS_NUMBER(text[i]);
       tm.tm_hour += (text[i+9]-'0')*n;
       n /= 10;
    }
@@ -217,6 +223,7 @@ static int date_from_ISO8601 (const char
    n = 10;
    tm.tm_min = 0;
    for(i = 0; i < 2; i++) {
+      XMLRPC_IS_NUMBER(text[i]);
       tm.tm_min += (text[i+12]-'0')*n;
       n /= 10;
    }
@@ -224,6 +231,7 @@ static int date_from_ISO8601 (const char
    n = 10;
    tm.tm_sec = 0;
    for(i = 0; i < 2; i++) {
+      XMLRPC_IS_NUMBER(text[i]);
       tm.tm_sec += (text[i+15]-'0')*n;
       n /= 10;
    }
Index: 5_2_4/ext/xmlrpc/xmlrpc-epi-php.c
===================================================================
--- 5_2_4.orig/ext/xmlrpc/xmlrpc-epi-php.c
+++ 5_2_4/ext/xmlrpc/xmlrpc-epi-php.c
@@ -1324,9 +1324,13 @@ int set_zval_xmlrpc_type(zval* value, XM
                   convert_to_object(value);
                   if(SUCCESS == zend_hash_update(Z_OBJPROP_P(value), OBJECT_TYPE_ATTR, sizeof(OBJECT_TYPE_ATTR), (void *) &type, sizeof(zval *), NULL)) {
                      bSuccess = zend_hash_update(Z_OBJPROP_P(value), OBJECT_VALUE_TS_ATTR, sizeof(OBJECT_VALUE_TS_ATTR), (void *) &ztimestamp, sizeof(zval *), NULL);
+                  } else {
+                     zval_ptr_dtor(&type);
                   }
                }
                XMLRPC_CleanupValue(v);
+            } else {
+               zval_ptr_dtor(&type);
             }
          }
          else {
Index: 5_2_4/Zend/zend_ini.c
===================================================================
--- 5_2_4.orig/Zend/zend_ini.c
+++ 5_2_4/Zend/zend_ini.c
@@ -231,20 +231,31 @@ ZEND_API void zend_ini_refresh_caches(in
 }
 #endif
 
-
 ZEND_API int zend_alter_ini_entry(char *name, uint name_length, char *new_value, uint new_value_length, int modify_type, int stage)
 {
+	TSRMLS_FETCH();
+
+	return zend_alter_ini_entry_ex(name, name_length, new_value, new_value_length, modify_type, stage, 0 TSRMLS_CC);
+}
+
+ZEND_API int zend_alter_ini_entry_ex(char *name, uint name_length, char *new_value, uint new_value_length, int modify_type, int stage, int force_change TSRMLS_DC)
+{
 	zend_ini_entry *ini_entry;
 	char *duplicate;
 	zend_bool modified;
-	TSRMLS_FETCH();
 
 	if (zend_hash_find(EG(ini_directives), name, name_length, (void **) &ini_entry)==FAILURE) {
 		return FAILURE;
 	}
 
-	if (!(ini_entry->modifiable & modify_type)) {
-		return FAILURE;
+	if (stage == ZEND_INI_STAGE_ACTIVATE && modify_type == ZEND_INI_SYSTEM) {
+		ini_entry->modifiable = ZEND_INI_SYSTEM;
+	}
+
+	if (!force_change) {
+		if (!(ini_entry->modifiable & modify_type)) {
+			return FAILURE;
+		}
 	}
 
 	modified = ini_entry->modified;
Index: 5_2_4/Zend/zend_ini.h
===================================================================
--- 5_2_4.orig/Zend/zend_ini.h
+++ 5_2_4/Zend/zend_ini.h
@@ -96,6 +96,7 @@ ZEND_API int zend_register_ini_entries(z
 ZEND_API void zend_unregister_ini_entries(int module_number TSRMLS_DC);
 ZEND_API void zend_ini_refresh_caches(int stage TSRMLS_DC);
 ZEND_API int zend_alter_ini_entry(char *name, uint name_length, char *new_value, uint new_value_length, int modify_type, int stage);
+ZEND_API int zend_alter_ini_entry_ex(char *name, uint name_length, char *new_value, uint new_value_length, int modify_type, int stage, int force_change TSRMLS_DC);
 ZEND_API int zend_restore_ini_entry(char *name, uint name_length, int stage);
 ZEND_API void display_ini_entries(zend_module_entry *module);
 
Index: 5_2_4/Zend/zend_vm_execute.h
===================================================================
--- 5_2_4.orig/Zend/zend_vm_execute.h
+++ 5_2_4/Zend/zend_vm_execute.h
@@ -442,7 +442,7 @@ static int ZEND_BEGIN_SILENCE_SPEC_HANDL
 	}
 
 	if (EG(error_reporting)) {
-		zend_alter_ini_entry("error_reporting", sizeof("error_reporting"), "0", 1, ZEND_INI_USER, ZEND_INI_STAGE_RUNTIME);
+		zend_alter_ini_entry_ex("error_reporting", sizeof("error_reporting"), "0", 1, ZEND_INI_USER, ZEND_INI_STAGE_RUNTIME, 1 TSRMLS_CC);
 	}
 	ZEND_VM_NEXT_OPCODE();
 }
@@ -592,7 +592,7 @@ static int ZEND_HANDLE_EXCEPTION_SPEC_HA
 		Z_TYPE(restored_error_reporting) = IS_LONG;
 		Z_LVAL(restored_error_reporting) = Z_LVAL_P(EX(old_error_reporting));
 		convert_to_string(&restored_error_reporting);
-		zend_alter_ini_entry("error_reporting", sizeof("error_reporting"), Z_STRVAL(restored_error_reporting), Z_STRLEN(restored_error_reporting), ZEND_INI_USER, ZEND_INI_STAGE_RUNTIME);
+		zend_alter_ini_entry_ex("error_reporting", sizeof("error_reporting"), Z_STRVAL(restored_error_reporting), Z_STRLEN(restored_error_reporting), ZEND_INI_USER, ZEND_INI_STAGE_RUNTIME, 1 TSRMLS_CC);
 		zendi_zval_dtor(restored_error_reporting);
 	}
 	EX(old_error_reporting) = NULL;
@@ -4922,7 +4922,7 @@ static int ZEND_END_SILENCE_SPEC_TMP_HAN
 		Z_TYPE(restored_error_reporting) = IS_LONG;
 		Z_LVAL(restored_error_reporting) = Z_LVAL(EX_T(opline->op1.u.var).tmp_var);
 		convert_to_string(&restored_error_reporting);
-		zend_alter_ini_entry("error_reporting", sizeof("error_reporting"), Z_STRVAL(restored_error_reporting), Z_STRLEN(restored_error_reporting), ZEND_INI_USER, ZEND_INI_STAGE_RUNTIME);
+		zend_alter_ini_entry_ex("error_reporting", sizeof("error_reporting"), Z_STRVAL(restored_error_reporting), Z_STRLEN(restored_error_reporting), ZEND_INI_USER, ZEND_INI_STAGE_RUNTIME, 1 TSRMLS_CC);
 		zendi_zval_dtor(restored_error_reporting);
 	}
 	if (EX(old_error_reporting) == &EX_T(opline->op1.u.var).tmp_var) {
Index: 5_2_4/ext/standard/array.c
===================================================================
--- 5_2_4.orig/ext/standard/array.c
+++ 5_2_4/ext/standard/array.c
@@ -78,6 +78,7 @@
 #define DIFF_NORMAL			1
 #define DIFF_KEY			2
 #define DIFF_ASSOC			6
+#define DIFF_COMP_DATA_NONE    -1
 #define DIFF_COMP_DATA_INTERNAL 0
 #define DIFF_COMP_DATA_USER     1
 #define DIFF_COMP_KEY_INTERNAL  0
@@ -86,6 +87,7 @@
 #define INTERSECT_NORMAL		1
 #define INTERSECT_KEY			2
 #define INTERSECT_ASSOC			6
+#define INTERSECT_COMP_DATA_NONE    -1
 #define INTERSECT_COMP_DATA_INTERNAL 0
 #define INTERSECT_COMP_DATA_USER     1
 #define INTERSECT_COMP_KEY_INTERNAL  0
@@ -2869,6 +2871,149 @@ PHP_FUNCTION(array_unique)
 }
 /* }}} */
 
+static int zval_compare(zval **a, zval **b TSRMLS_DC) /* {{{ */
+{
+	zval result;
+	zval *first;
+	zval *second;
+
+	first = *((zval **) a);
+	second = *((zval **) b);
+
+	if (string_compare_function(&result, first, second TSRMLS_CC) == FAILURE) {
+		return 0;
+	}
+
+	if (Z_TYPE(result) == IS_DOUBLE) {
+		if (Z_DVAL(result) < 0) {
+			return -1;
+		} else if (Z_DVAL(result) > 0) {
+			return 1;
+		} else {
+			return 0;
+		}
+	}
+
+	convert_to_long(&result);
+
+	if (Z_LVAL(result) < 0) {
+		return -1;
+	} else if (Z_LVAL(result) > 0) {
+		return 1;
+	}
+
+	return 0;
+}
+/* }}} */
+
+static int zval_user_compare(zval **a, zval **b TSRMLS_DC) /* {{{ */
+{
+	zval **args[2];
+	zval *retval_ptr;
+	zend_fcall_info fci;
+
+	args[0] = (zval **) a;
+	args[1] = (zval **) b;
+
+	fci.size = sizeof(fci);
+	fci.function_table = EG(function_table);
+	fci.function_name = *BG(user_compare_func_name);
+	fci.symbol_table = NULL;
+	fci.object_pp = NULL;
+	fci.retval_ptr_ptr = &retval_ptr;
+	fci.param_count = 2;
+	fci.params = args;
+	fci.no_separation = 0;
+
+	if (zend_call_function(&fci, &BG(user_compare_fci_cache) TSRMLS_CC)== SUCCESS
+			&& retval_ptr) {
+		long retval;
+
+		convert_to_long_ex(&retval_ptr);
+		retval = Z_LVAL_P(retval_ptr);
+		zval_ptr_dtor(&retval_ptr);
+		return retval < 0 ? -1 : retval > 0 ? 1 : 0;;
+	} else {
+		return 0;
+	}
+}
+/* }}} */
+
+static void php_array_intersect_key(INTERNAL_FUNCTION_PARAMETERS, int data_compare_type) /* {{{ */
+{
+	Bucket *p;
+	int argc, i;
+	zval ***args;
+	int (*intersect_data_compare_func)(zval **, zval ** TSRMLS_DC) = NULL;
+	zend_bool ok;
+	zval **data;
+
+	/* Get the argument count */
+	argc = ZEND_NUM_ARGS();
+	/* Allocate arguments array and get the arguments, checking for errors. */
+	args = (zval ***)safe_emalloc(argc, sizeof(zval **), 0);
+	if (argc < 2 || zend_get_parameters_array_ex(argc, args) == FAILURE) {
+		efree(args);
+		WRONG_PARAM_COUNT;
+	}
+	if (data_compare_type == INTERSECT_COMP_DATA_USER) {
+		char *callback_name;
+
+		if (argc < 3) {
+			efree(args);
+			WRONG_PARAM_COUNT;
+		}
+		argc--;
+		if (!zend_is_callable(*args[argc], 0, &callback_name)) {
+			php_error_docref(NULL TSRMLS_CC, E_WARNING, "Not a valid callback %s", callback_name);
+			efree(callback_name);
+			efree(args);
+			return;
+		}
+		efree(callback_name);
+		intersect_data_compare_func = zval_user_compare;
+		BG(user_compare_func_name) = args[argc];
+	} else if (data_compare_type == INTERSECT_COMP_DATA_INTERNAL) {
+		intersect_data_compare_func = zval_compare;
+	}
+
+	array_init(return_value);
+
+	for (p = Z_ARRVAL_PP(args[0])->pListHead; p != NULL; p = p->pListNext) {
+		if (p->nKeyLength == 0) {
+			ok = 1;
+			for (i = 1; i < argc; i++) {
+				if (zend_hash_index_find(Z_ARRVAL_PP(args[i]), p->h, (void**)&data) == FAILURE ||
+						(intersect_data_compare_func &&
+						 intersect_data_compare_func((zval**)p->pData, data TSRMLS_CC) != 0)) {
+					ok = 0;
+					break;
+				}
+			}
+			if (ok) {
+				(*((zval**)p->pData))->refcount++;
+				zend_hash_index_update(Z_ARRVAL_P(return_value), p->h, p->pData, sizeof(zval*), NULL);
+			}
+		} else {
+			ok = 1;
+			for (i = 1; i < argc; i++) {
+				if (zend_hash_quick_find(Z_ARRVAL_PP(args[i]), p->arKey, p->nKeyLength, p->h, (void**)&data) == FAILURE ||
+						(intersect_data_compare_func &&
+						 intersect_data_compare_func((zval**)p->pData, data TSRMLS_CC) != 0)) {
+					ok = 0;
+					break;
+				}
+			}
+			if (ok) {
+				(*((zval**)p->pData))->refcount++;
+				zend_hash_quick_update(Z_ARRVAL_P(return_value), p->arKey, p->nKeyLength, p->h, p->pData, sizeof(zval*), NULL);
+			}
+		}
+	}
+	efree(args);
+}
+/* }}} */
+
 static void php_array_intersect(INTERNAL_FUNCTION_PARAMETERS, int behavior, int data_compare_type, int key_compare_type) /* {{{ */
 {
 	zval ***args = NULL;
@@ -3185,8 +3330,7 @@ out:
    Returns the entries of arr1 that have keys which are present in all the other arguments. Kind of equivalent to array_diff(array_keys($arr1), array_keys($arr2)[,array_keys(...)]). Equivalent of array_intersect_assoc() but does not do compare of the data. */
 PHP_FUNCTION(array_intersect_key)
 {
-	php_array_intersect(INTERNAL_FUNCTION_PARAM_PASSTHRU, INTERSECT_KEY,
-				INTERSECT_COMP_DATA_INTERNAL, INTERSECT_COMP_KEY_INTERNAL);
+	php_array_intersect_key(INTERNAL_FUNCTION_PARAM_PASSTHRU, INTERSECT_COMP_DATA_NONE);
 }
 /* }}} */
 
@@ -3221,8 +3365,7 @@ PHP_FUNCTION(array_uintersect)
    Returns the entries of arr1 that have values which are present in all the other arguments. Keys are used to do more restrictive check */
 PHP_FUNCTION(array_intersect_assoc)
 {
-	php_array_intersect(INTERNAL_FUNCTION_PARAM_PASSTHRU, INTERSECT_ASSOC,
-				INTERSECT_COMP_DATA_INTERNAL, INTERSECT_COMP_KEY_INTERNAL);
+	php_array_intersect_key(INTERNAL_FUNCTION_PARAM_PASSTHRU, INTERSECT_COMP_DATA_INTERNAL);
 }
 /* }}} */
 
@@ -3230,8 +3373,7 @@ PHP_FUNCTION(array_intersect_assoc)
    Returns the entries of arr1 that have values which are present in all the other arguments. Keys are used to do more restrictive check. Data is compared by using an user-supplied callback. */
 PHP_FUNCTION(array_uintersect_assoc)
 {
-	php_array_intersect(INTERNAL_FUNCTION_PARAM_PASSTHRU, INTERSECT_ASSOC,
-				INTERSECT_COMP_DATA_USER, INTERSECT_COMP_KEY_INTERNAL);
+	php_array_intersect_key(INTERNAL_FUNCTION_PARAM_PASSTHRU, INTERSECT_COMP_DATA_USER);
 }
 /* }}} */
 
@@ -3253,6 +3395,81 @@ PHP_FUNCTION(array_uintersect_uassoc)
 }
 /* }}} */
 
+static void php_array_diff_key(INTERNAL_FUNCTION_PARAMETERS, int data_compare_type) /* {{{ */
+{
+	Bucket *p;
+	int argc, i;
+	zval ***args;
+	int (*diff_data_compare_func)(zval **, zval ** TSRMLS_DC) = NULL;
+	zend_bool ok;
+	zval **data;
+
+	/* Get the argument count */
+	argc = ZEND_NUM_ARGS();
+	/* Allocate arguments array and get the arguments, checking for errors. */
+	args = (zval ***)safe_emalloc(argc, sizeof(zval **), 0);
+	if (argc < 2 || zend_get_parameters_array_ex(argc, args) == FAILURE) {
+		efree(args);
+		WRONG_PARAM_COUNT;
+	}
+	if (data_compare_type == DIFF_COMP_DATA_USER) {
+		char *callback_name;
+
+		if (argc < 3) {
+			efree(args);
+			WRONG_PARAM_COUNT;
+		}
+		argc--;
+		if (!zend_is_callable(*args[argc], 0, &callback_name)) {
+			php_error_docref(NULL TSRMLS_CC, E_WARNING, "Not a valid callback %s", callback_name);
+			efree(callback_name);
+			efree(args);
+			return;
+		}
+		efree(callback_name);
+		diff_data_compare_func = zval_user_compare;
+		BG(user_compare_func_name) = args[argc];
+	} else if (data_compare_type == DIFF_COMP_DATA_INTERNAL) {
+		diff_data_compare_func = zval_compare;
+	}
+
+	array_init(return_value);
+
+	for (p = Z_ARRVAL_PP(args[0])->pListHead; p != NULL; p = p->pListNext) {
+		if (p->nKeyLength == 0) {
+			ok = 1;
+			for (i = 1; i < argc; i++) {
+				if (zend_hash_index_find(Z_ARRVAL_PP(args[i]), p->h, (void**)&data) == SUCCESS &&
+						(!diff_data_compare_func ||
+						 diff_data_compare_func((zval**)p->pData, data TSRMLS_CC) == 0)) {
+					ok = 0;
+					break;
+				}
+			}
+			if (ok) {
+				(*((zval**)p->pData))->refcount++;
+				zend_hash_index_update(Z_ARRVAL_P(return_value), p->h, p->pData, sizeof(zval*), NULL);
+			}
+		} else {
+			ok = 1;
+			for (i = 1; i < argc; i++) {
+				if (zend_hash_quick_find(Z_ARRVAL_PP(args[i]), p->arKey, p->nKeyLength, p->h, (void**)&data) == SUCCESS &&
+						(!diff_data_compare_func ||
+						 diff_data_compare_func((zval**)p->pData, data TSRMLS_CC) == 0)) {
+					ok = 0;
+					break;
+				}
+			}
+			if (ok) {
+				(*((zval**)p->pData))->refcount++;
+				zend_hash_quick_update(Z_ARRVAL_P(return_value), p->arKey, p->nKeyLength, p->h, p->pData, sizeof(zval*), NULL);
+			}
+		}
+	}
+	efree(args);
+}
+/* }}} */
+
 static void php_array_diff(INTERNAL_FUNCTION_PARAMETERS, int behavior, int data_compare_type, int key_compare_type) /* {{{ */
 {
 	zval ***args = NULL;
@@ -3567,8 +3784,7 @@ out:
    Returns the entries of arr1 that have keys which are not present in any of the others arguments. This function is like array_diff() but works on the keys instead of the values. The associativity is preserved. */
 PHP_FUNCTION(array_diff_key)
 {
-	php_array_diff(INTERNAL_FUNCTION_PARAM_PASSTHRU, DIFF_KEY,
-			 DIFF_COMP_DATA_INTERNAL, DIFF_COMP_KEY_INTERNAL);
+	php_array_diff_key(INTERNAL_FUNCTION_PARAM_PASSTHRU, DIFF_COMP_DATA_NONE);
 }
 /* }}} */
 
@@ -3603,8 +3819,7 @@ PHP_FUNCTION(array_udiff)
    Returns the entries of arr1 that have values which are not present in any of the others arguments but do additional checks whether the keys are equal */
 PHP_FUNCTION(array_diff_assoc)
 {
-	php_array_diff(INTERNAL_FUNCTION_PARAM_PASSTHRU, DIFF_ASSOC,
-			 DIFF_COMP_DATA_INTERNAL, DIFF_COMP_KEY_INTERNAL);
+	php_array_diff_key(INTERNAL_FUNCTION_PARAM_PASSTHRU, DIFF_COMP_DATA_INTERNAL);
 }
 /* }}} */
 
@@ -3621,8 +3836,7 @@ PHP_FUNCTION(array_diff_uassoc)
    Returns the entries of arr1 that have values which are not present in any of the others arguments but do additional checks whether the keys are equal. Keys are compared by user supplied function. */
 PHP_FUNCTION(array_udiff_assoc)
 {
-	php_array_diff(INTERNAL_FUNCTION_PARAM_PASSTHRU, DIFF_ASSOC,
-			 DIFF_COMP_DATA_USER, DIFF_COMP_KEY_INTERNAL);
+	php_array_diff_key(INTERNAL_FUNCTION_PARAM_PASSTHRU, DIFF_COMP_DATA_USER);
 }
 /* }}} */
 
Index: 5_2_4/zend-endian-uni.diff
===================================================================
--- /dev/null
+++ 5_2_4/zend-endian-uni.diff
@@ -0,0 +1,57 @@
+Index: Zend/zend_strtod.c
+===================================================================
+RCS file: /repository/ZendEngine2/zend_strtod.c,v
+retrieving revision 1.17.2.2.2.10
+diff -u -p -d -r1.17.2.2.2.10 zend_strtod.c
+--- Zend/zend_strtod.c	26 Apr 2007 23:13:25 -0000	1.17.2.2.2.10
++++ Zend/zend_strtod.c	29 May 2007 13:14:31 -0000
+@@ -135,7 +135,7 @@ typedef unsigned long int uint32_t;
+ # endif
+ #endif
+ 
+-#ifdef WORDS_BIGENDIAN
++#ifdef __BIG_ENDIAN__
+ #define IEEE_BIG_ENDIAN
+ #else
+ #define IEEE_LITTLE_ENDIAN
+Index: ext/date/lib/parse_tz.c
+===================================================================
+RCS file: /repository/php-src/ext/date/lib/parse_tz.c,v
+retrieving revision 1.20.2.6.2.12
+diff -u -p -d -r1.20.2.6.2.12 parse_tz.c
+--- ext/date/lib/parse_tz.c	25 Jan 2007 14:38:45 -0000	1.20.2.6.2.12
++++ ext/date/lib/parse_tz.c	29 May 2007 13:14:31 -0000
+@@ -33,7 +33,7 @@
+ #endif
+ #include "timezonedb.h"
+ 
+-#ifdef WORDS_BIGENDIAN
++#ifdef __BIG_ENDIAN__ 
+ #define timelib_conv_int(l) (l)
+ #else
+ #define timelib_conv_int(l) ((l & 0x000000ff) << 24) + ((l & 0x0000ff00) << 8) + ((l & 0x00ff0000) >> 8) + ((l & 0xff000000) >> 24)
+Index: ext/hash/hash_tiger.c
+===================================================================
+RCS file: /repository/php-src/ext/hash/hash_tiger.c,v
+retrieving revision 1.4.2.4.2.2
+diff -u -p -d -r1.4.2.4.2.2 hash_tiger.c
+--- ext/hash/hash_tiger.c	8 Jan 2007 22:29:25 -0000	1.4.2.4.2.2
++++ ext/hash/hash_tiger.c	29 May 2007 13:14:32 -0000
+@@ -91,7 +91,7 @@
+ #define split_ex(str) \
+ 	x0=str[0]; x1=str[1]; x2=str[2]; x3=str[3]; \
+ 	x4=str[4]; x5=str[5]; x6=str[6]; x7=str[7];
+-#ifdef WORDS_BIGENDIAN
++#ifdef __BIG_ENDIAN__ 
+ #	define split(str) \
+ 	{ \
+ 		int i; \
+@@ -144,7 +144,7 @@ static inline void TigerFinalize(PHP_TIG
+ 		memset(&context->buffer[context->length], 0, 56 - context->length);
+ 	}
+ 
+-#ifndef WORDS_BIGENDIAN	
++#ifndef __BIG_ENDIAN__ 
+ 	memcpy(&context->buffer[56], &context->passed, sizeof(php_hash_uint64));
+ #else
+ 	context->buffer[56] = (unsigned char) (context->passed & 0xff);
Index: 5_2_4/win32/build/config.w32
===================================================================
--- 5_2_4.orig/win32/build/config.w32
+++ 5_2_4/win32/build/config.w32
@@ -316,6 +316,8 @@ ADD_SOURCES("regex", "regcomp.c regerror
 
 STDOUT.WriteBlankLines(1);
 
+ARG_ENABLE("memory-limit", "dummy", "no");
+
 /* Can we build with IPv6 support? */
 ARG_ENABLE("ipv6", "Disable IPv6 support (default is turn it on if available)", "yes");
 
Index: 5_2_4/Zend/zend_execute.c
===================================================================
--- 5_2_4.orig/Zend/zend_execute.c
+++ 5_2_4/Zend/zend_execute.c
@@ -735,10 +735,11 @@ static inline void zend_assign_to_variab
  			if (variable_ptr != value) {
  				zend_uint refcount = variable_ptr->refcount;
  				zval garbage;
- 
+#ifndef ZEND_WIN32
  				if (type != IS_TMP_VAR) {
  					value->refcount++;
  				}
+#endif
  				garbage = *variable_ptr;
  				*variable_ptr = *value;
  				variable_ptr->refcount = refcount;
@@ -746,7 +747,9 @@ static inline void zend_assign_to_variab
  				zend_error(E_STRICT, "Implicit cloning object of class '%s' because of 'zend.ze1_compatibility_mode'", class_name);
  				variable_ptr->value.obj = Z_OBJ_HANDLER_P(value, clone_obj)(value TSRMLS_CC);
  				if (type != IS_TMP_VAR) {
+#ifndef ZEND_WIN32
  					value->refcount--;
+#endif
  				}
  				zendi_zval_dtor(garbage);
  			}
@@ -774,17 +777,20 @@ static inline void zend_assign_to_variab
 		if (variable_ptr!=value) {
 			zend_uint refcount = variable_ptr->refcount;
 			zval garbage;
-
+#ifndef ZEND_WIN32
 			if (type!=IS_TMP_VAR) {
 				value->refcount++;
 			}
+#endif
 			garbage = *variable_ptr;
 			*variable_ptr = *value;
 			variable_ptr->refcount = refcount;
 			variable_ptr->is_ref = 1;
 			if (type!=IS_TMP_VAR) {
 				zendi_zval_copy_ctor(*variable_ptr);
+#ifndef ZEND_WIN32
 				value->refcount--;
+#endif
 			}
 			zendi_zval_dtor(garbage);
 		}
Index: 5_2_4/sapi/cgi/cgi_main.c
===================================================================
--- 5_2_4.orig/sapi/cgi/cgi_main.c
+++ 5_2_4/sapi/cgi/cgi_main.c
@@ -141,6 +141,7 @@ static const opt_struct OPTIONS[] = {
 	{'?', 0, "usage"},/* help alias (both '?' and 'usage') */
 	{'v', 0, "version"},
 	{'z', 1, "zend-extension"},
+ 	{'R', 1, "repeat"},
 	{'-', 0, NULL} /* end of args */
 };
 
@@ -1175,6 +1176,9 @@ int main(int argc, char *argv[])
 	int status = 0;
 #endif
 #endif /* PHP_FASTCGI */
+	int benchmark = 0;
+	int repeats = 1;
+	struct timeval start, end;
 
 #if 0 && defined(PHP_DEBUG)
 	/* IIS is always making things more difficult.  This allows
@@ -1460,6 +1464,10 @@ consult the installation file that came 
 	zend_first_try {
 		while ((c = php_getopt(argc, argv, OPTIONS, &php_optarg, &php_optind, 1)) != -1) {
 			switch (c) {
+				case 'R': 
+				        benchmark = 1;
+						repeats = atoi(php_optarg);
+						break;
 				case 'h':
 				case '?':
 #if PHP_FASTCGI
@@ -1477,6 +1485,9 @@ consult the installation file that came 
 		}
 		php_optind = orig_optind;
 		php_optarg = orig_optarg;
+		if (benchmark) {
+			gettimeofday(&start, NULL);
+		}
 
 #if PHP_FASTCGI
 		/* start of FAST CGI loop */
@@ -1860,11 +1871,12 @@ fastcgi_request_done:
 
 		}
 
+		repeats--;
 #if PHP_FASTCGI
-			if (!fastcgi) break;
+			if (!fastcgi && repeats <= 0) break;
 			/* only fastcgi will get here */
 			requests++;
-			if (max_requests && (requests == max_requests)) {
+			if (fastcgi && max_requests && (requests == max_requests)) {
 				fcgi_finish_request(&request);
 				if (bindpath) {
 					free(bindpath);
@@ -1875,6 +1887,9 @@ fastcgi_request_done:
 				}
 				break;
 			}
+			php_optind = orig_optind;
+			php_optarg = orig_optarg;
+
 			/* end of fastcgi loop */
 		}
 		fcgi_shutdown();
@@ -1890,6 +1905,18 @@ fastcgi_request_done:
 		exit_status = 255;
 	} zend_end_try();
 
+	if (benchmark) {
+		gettimeofday(&end, NULL);
+		end.tv_sec -= start.tv_sec;
+		if (end.tv_usec >= start.tv_usec) {
+			end.tv_usec -= start.tv_usec;
+		} else {
+			end.tv_sec -= 1;
+			end.tv_usec = end.tv_usec + 1000000 - start.tv_usec;
+		}
+		fprintf(stderr, "\nElapsed time: %d.%06d sec\n", end.tv_sec, start.tv_usec);
+	}
+
 	SG(server_context) = NULL;
 	php_module_shutdown(TSRMLS_C);
 	sapi_shutdown();
Index: 5_2_4/sapi/apache/mod_php5.c
===================================================================
--- 5_2_4.orig/sapi/apache/mod_php5.c
+++ 5_2_4/sapi/apache/mod_php5.c
@@ -22,6 +22,8 @@
 #include "php_apache_http.h"
 #include "http_conf_globals.h"
 
+#include "ext/apollo/php_apollo.h"
+
 #ifdef NETWARE
 #define SIGPIPE SIGINT
 #endif
@@ -951,6 +953,7 @@ static void php_init_handler(server_rec 
 	{
 		TSRMLS_FETCH();
 		if (PG(expose_php)) {
+			ap_add_version_component("Zend Core/" APOLLO_VERSION);
 			ap_add_version_component("PHP/" PHP_VERSION);
 		}
 	}
Index: 5_2_4/sapi/apache2handler/sapi_apache2.c
===================================================================
--- 5_2_4.orig/sapi/apache2handler/sapi_apache2.c
+++ 5_2_4/sapi/apache2handler/sapi_apache2.c
@@ -53,6 +53,8 @@
 
 #include "php_apache.h"
 
+#include "ext/apollo/php_apollo.h"
+
 /* UnixWare and Netware define shutdown to _shutdown, which causes problems later
  * on when using a structure member named shutdown. Since this source
  * file does not use the system call shutdown, it is safe to #undef it.K
@@ -372,6 +374,7 @@ static void php_apache_add_version(apr_p
 {
 	TSRMLS_FETCH();
 	if (PG(expose_php)) {
+		ap_add_version_component(p, "Zend Core/" APOLLO_VERSION);
 		ap_add_version_component(p, "PHP/" PHP_VERSION);
 	}
 }
Index: 5_2_4/ext/odbc/config.m4
===================================================================
--- 5_2_4.orig/ext/odbc/config.m4
+++ 5_2_4/ext/odbc/config.m4
@@ -99,75 +99,6 @@ AC_DEFUN([PHP_ODBC_FIND_EMPRESS_BCS_LIBS
 dnl
 dnl configure options
 dnl
-if test -z "$ODBC_TYPE"; then
-PHP_ARG_WITH(adabas,,
-[  --with-adabas[=DIR]     Include Adabas D support [/usr/local]])
-
-  if test "$PHP_ADABAS" != "no"; then
-    AC_MSG_CHECKING([for Adabas support])
-    if test "$PHP_ADABAS" = "yes"; then
-      PHP_ADABAS=/usr/local
-    fi
-    PHP_ADD_INCLUDE($PHP_ADABAS/incl)
-    PHP_ADD_LIBPATH($PHP_ADABAS/$PHP_LIBDIR)
-    ODBC_OBJS="$PHP_ADABAS/$PHP_LIBDIR/odbclib.a"
-    ODBC_LIB="$abs_builddir/ext/odbc/libodbc_adabas.a"
-    $srcdir/build/shtool mkdir -f -p ext/odbc
-    rm -f "$ODBC_LIB"
-    cp "$ODBC_OBJS" "$ODBC_LIB"
-    PHP_ADD_LIBRARY(sqlptc)
-    PHP_ADD_LIBRARY(sqlrte)
-    PHP_ADD_LIBRARY_WITH_PATH(odbc_adabas, $abs_builddir/ext/odbc)
-    ODBC_TYPE=adabas
-    ODBC_INCDIR=$PHP_ADABAS/incl
-    PHP_ODBC_CHECK_HEADER(sqlext.h)
-    AC_DEFINE(HAVE_ADABAS,1,[ ])
-    AC_MSG_RESULT([$ext_output])
-  fi
-fi
-
-if test -z "$ODBC_TYPE"; then
-PHP_ARG_WITH(sapdb,,
-[  --with-sapdb[=DIR]      Include SAP DB support [/usr/local]])
-
-  if test "$PHP_SAPDB" != "no"; then
-    AC_MSG_CHECKING([for SAP DB support])
-    if test "$PHP_SAPDB" = "yes"; then
-      PHP_SAPDB=/usr/local
-    fi
-    PHP_ADD_INCLUDE($PHP_SAPDB/incl)
-    PHP_ADD_LIBPATH($PHP_SAPDB/$PHP_LIBDIR)
-    PHP_ADD_LIBRARY(sqlod)
-    ODBC_TYPE=sapdb
-    AC_DEFINE(HAVE_SAPDB,1,[ ])
-    AC_MSG_RESULT([$ext_output])
-  fi
-fi
-
-if test -z "$ODBC_TYPE"; then
-PHP_ARG_WITH(solid,,
-[  --with-solid[=DIR]      Include Solid support [/usr/local/solid]])
-
-  if test "$PHP_SOLID" != "no"; then
-    AC_MSG_CHECKING(for Solid support)
-    if test "$PHP_SOLID" = "yes"; then
-      PHP_SOLID=/usr/local/solid
-    fi
-    ODBC_INCDIR=$PHP_SOLID/include
-    ODBC_LIBDIR=$PHP_SOLID/$PHP_LIBDIR
-    ODBC_INCLUDE=-I$ODBC_INCDIR
-    ODBC_TYPE=solid
-    if test -f $ODBC_LIBDIR/soc*35.a; then
-      AC_DEFINE(HAVE_SOLID_35,1,[ ])
-    elif test -f $ODBC_LIBDIR/scl*30.a; then
-      AC_DEFINE(HAVE_SOLID_30,1,[ ])
-    elif test -f $ODBC_LIBDIR/scl*23.a; then
-      AC_DEFINE(HAVE_SOLID,1,[ ])
-    fi
-    AC_MSG_RESULT([$ext_output])
-    PHP_ODBC_FIND_SOLID_LIBS($ODBC_LIBDIR)
-  fi
-fi
 
 if test -z "$ODBC_TYPE"; then
 PHP_ARG_WITH(ibm-db2,,
@@ -206,276 +137,6 @@ You need to source your DB2 environment 
   fi
 fi
 
-if test -z "$ODBC_TYPE"; then
-PHP_ARG_WITH(ODBCRouter,,
-[  --with-ODBCRouter[=DIR] Include ODBCRouter.com support [/usr]])
-
-  if test "$PHP_ODBCROUTER" != "no"; then
-    AC_MSG_CHECKING(for ODBCRouter.com support)
-    if test "$PHP_ODBCROUTER" = "yes"; then
-      PHP_ODBCROUTER=/usr
-    fi
-    ODBC_INCDIR=$PHP_ODBCROUTER/include
-    ODBC_LIBDIR=$PHP_ODBCROUTER/lib
-    ODBC_LFLAGS=-L$ODBC_LIBDIR
-    ODBC_INCLUDE=-I$ODBC_INCDIR
-    ODBC_LIBS=-lodbcsdk
-    ODBC_TYPE=ODBCRouter
-    AC_DEFINE(HAVE_ODBC_ROUTER,1,[ ])
-    AC_MSG_RESULT([$ext_output])
-  fi
-fi
-
-if test -z "$ODBC_TYPE"; then
-PHP_ARG_WITH(empress,,
-[  --with-empress[=DIR]    Include Empress support [\$EMPRESSPATH]
-                          (Empress Version >= 8.60 required)])
-
-  if test "$PHP_EMPRESS" != "no"; then
-    AC_MSG_CHECKING(for Empress support)
-    if test "$PHP_EMPRESS" = "yes"; then
-      ODBC_INCDIR=$EMPRESSPATH/include/odbc
-      ODBC_LIBDIR=$EMPRESSPATH/shlib
-    else
-      ODBC_INCDIR=$PHP_EMPRESS/include/odbc
-      ODBC_LIBDIR=$PHP_EMPRESS/shlib
-    fi
-    ODBC_INCLUDE=-I$ODBC_INCDIR
-    ODBC_LFLAGS=-L$ODBC_LIBDIR
-    ODBC_TYPE=empress
-    AC_DEFINE(HAVE_EMPRESS,1,[ ])
-    AC_MSG_RESULT([$ext_output])
-    PHP_ODBC_FIND_EMPRESS_LIBS($ODBC_LIBDIR)
-  fi
-fi
-
-if test -z "$ODBC_TYPE"; then
-PHP_ARG_WITH(empress-bcs,,
-[  --with-empress-bcs[=DIR]
-                          Include Empress Local Access support [\$EMPRESSPATH]
-                          (Empress Version >= 8.60 required)])
-
-  if test "$PHP_EMPRESS_BCS" != "no"; then
-    AC_MSG_CHECKING(for Empress local access support)
-    if test "$PHP_EMPRESS_BCS" = "yes"; then
-      ODBC_INCDIR=$EMPRESSPATH/include/odbc
-      ODBC_LIBDIR=$EMPRESSPATH/shlib
-    else
-      ODBC_INCDIR=$PHP_EMPRESS_BCS/include/odbc
-      ODBC_LIBDIR=$PHP_EMPRESS_BCS/shlib
-    fi
-    CC="empocc -bcs";export CC;
-    LD="empocc -bcs";export LD;
-    ODBC_INCLUDE=-I$ODBC_INCDIR
-    ODBC_LFLAGS=-L$ODBC_LIBDIR
-    LIST=`empocc -listlines -bcs -o a a.c`
-
-    NEWLIST=
-    for I in $LIST
-    do
-      case $I in
-        $EMPRESSPATH/odbccl/lib/* | \
-        $EMPRESSPATH/rdbms/lib/* | \
-        $EMPRESSPATH/common/lib/*)
-              NEWLIST="$NEWLIST $I"
-              ;;
-      esac
-    done
-    ODBC_LIBS="-lempphpbcs -lms -lmscfg -lbasic -lbasic_os -lnlscstab -lnlsmsgtab -lm -ldl -lcrypt"
-    ODBC_TYPE=empress-bcs
-    AC_DEFINE(HAVE_EMPRESS,1,[ ])
-    AC_MSG_RESULT([$ext_output])
-    PHP_ODBC_FIND_EMPRESS_BCS_LIBS($ODBC_LIBDIR)
-  fi
-fi
-
-if test -z "$ODBC_TYPE"; then
-PHP_ARG_WITH(birdstep,,
-[  --with-birdstep[=DIR]   Include Birdstep support [/usr/local/birdstep]])
-  
-  if test "$PHP_BIRDSTEP" != "no"; then
-    AC_MSG_CHECKING(for Birdstep support)
-    if test "$PHP_BIRDSTEP" = "yes"; then
-        ODBC_INCDIR=/usr/local/birdstep/include
-        ODBC_LIBDIR=/usr/local/birdstep/lib
-    else
-        ODBC_INCDIR=$PHP_BIRDSTEP/include
-        ODBC_LIBDIR=$PHP_BIRDSTEP/$PHP_LIBDIR
-    fi
-   
-    case $host_alias in
-      *aix*[)]
-        AC_DEFINE(AIX,1,[ ]);;
-      *hpux*[)]
-        AC_DEFINE(HPUX,1,[ ]);;
-      *linux*[)]
-        AC_DEFINE(LINUX,1,[ ]);;
-      *qnx*[)]
-        AC_DEFINE(NEUTRINO,1,[ ]);;
-      i?86-*-solaris*[)]
-        AC_DEFINE(ISOLARIS,1,[ ]);;
-      sparc-*-solaris*[)]
-        AC_DEFINE(SOLARIS,1,[ ]);;
-      *unixware*[)]
-        AC_DEFINE(UNIXWARE,1,[ ]);;
-    esac
-
-    ODBC_INCLUDE=-I$ODBC_INCDIR
-    ODBC_TYPE=birdstep
-    ODBC_LFLAGS=-L$ODBC_LIBDIR
-    ODBC_LIBS="-lCadm -lCdict -lCenc -lCrdm -lCrpc -lCrdbc -lCrm -lCuapi -lutil"
-
-    if test -f "$ODBC_LIBDIR/libCrdbc32.$SHLIB_SUFFIX_NAME"; then
-      ODBC_LIBS="-lCrdbc32 -lCadm32 -lCncp32 -lCrm32 -lCsql32 -lCdict32 -lCrdm32 -lCrpc32 -lutil"
-    elif test -f "$ODBC_LIBDIR/libCrdbc.$SHLIB_SUFFIX_NAME"; then
-      ODBC_LIBS="-lCrdbc -lCadm -lCncp -lCrm -lCsql -lCdict -lCrdm -lCrpc -lutil"
-    fi
-
-    AC_DEFINE(HAVE_BIRDSTEP,1,[ ])
-    AC_MSG_RESULT([$ext_output])
-  fi
-fi
-
-if test -z "$ODBC_TYPE"; then
-PHP_ARG_WITH(custom-odbc,,
-[  --with-custom-odbc[=DIR]
-                          Include user defined ODBC support. DIR is ODBC install base
-                          directory [/usr/local]. Make sure to define CUSTOM_ODBC_LIBS and
-                          have some odbc.h in your include dirs. f.e. you should define 
-                          following for Sybase SQL Anywhere 5.5.00 on QNX, prior to
-                          running this configure script:
-                              CPPFLAGS=\"-DODBC_QNX -DSQLANY_BUG\"
-                              LDFLAGS=-lunix
-                              CUSTOM_ODBC_LIBS=\"-ldblib -lodbc\"])
-
-  if test "$PHP_CUSTOM_ODBC" != "no"; then
-    AC_MSG_CHECKING(for a custom ODBC support)
-    if test "$PHP_CUSTOM_ODBC" = "yes"; then
-      PHP_CUSTOM_ODBC=/usr/local
-    fi
-    ODBC_INCDIR=$PHP_CUSTOM_ODBC/include
-    ODBC_LIBDIR=$PHP_CUSTOM_ODBC/$PHP_LIBDIR
-    ODBC_LFLAGS=-L$ODBC_LIBDIR
-    ODBC_INCLUDE=-I$ODBC_INCDIR
-    ODBC_LIBS=$CUSTOM_ODBC_LIBS
-    ODBC_TYPE=custom-odbc
-    AC_DEFINE(HAVE_CODBC,1,[ ])
-    AC_MSG_RESULT([$ext_ouput])
-  fi
-fi
-
-if test -z "$ODBC_TYPE"; then
-PHP_ARG_WITH(iodbc,,
-[  --with-iodbc[=DIR]      Include iODBC support [/usr/local]])
-
-  if test "$PHP_IODBC" != "no"; then
-    AC_MSG_CHECKING(for iODBC support)
-    if test "$PHP_IODBC" = "yes"; then
-      PHP_IODBC=/usr/local
-    fi
-    PHP_ADD_LIBRARY_WITH_PATH(iodbc, $PHP_IODBC/$PHP_LIBDIR)
-    PHP_ADD_INCLUDE($PHP_IODBC/include, 1)
-    ODBC_TYPE=iodbc
-    ODBC_INCLUDE=-I$PHP_IODBC/include
-    ODBC_LFLAGS=-L$PHP_IODBC/$PHP_LIBDIR
-    ODBC_LIBS=-liodbc
-    AC_DEFINE(HAVE_IODBC,1,[ ])
-    AC_DEFINE(HAVE_ODBC2,1,[ ])
-    AC_MSG_RESULT([$ext_output])
-  fi
-fi
-
-if test -z "$ODBC_TYPE"; then
-PHP_ARG_WITH(esoob,,
-[  --with-esoob[=DIR]      Include Easysoft OOB support [/usr/local/easysoft/oob/client]])
-
-  if test "$PHP_ESOOB" != "no"; then
-    AC_MSG_CHECKING(for Easysoft ODBC-ODBC Bridge support)
-    if test "$PHP_ESOOB" = "yes"; then
-      PHP_ESOOB=/usr/local/easysoft/oob/client
-    fi
-    ODBC_INCDIR=$PHP_ESOOB/include
-    ODBC_LIBDIR=$PHP_ESOOB/$PHP_LIBDIR
-    ODBC_LFLAGS=-L$ODBC_LIBDIR
-    ODBC_INCLUDE=-I$ODBC_INCDIR
-    ODBC_LIBS=-lesoobclient
-    ODBC_TYPE=esoob
-    AC_DEFINE(HAVE_ESOOB,1,[ ])
-    AC_MSG_RESULT([$ext_output])
-  fi
-fi
-
-if test -z "$ODBC_TYPE"; then
-PHP_ARG_WITH(unixODBC,,
-[  --with-unixODBC[=DIR]   Include unixODBC support [/usr/local]])
-
-  if test "$PHP_UNIXODBC" != "no"; then
-    AC_MSG_CHECKING(for unixODBC support)
-    if test "$PHP_UNIXODBC" = "yes"; then
-      PHP_UNIXODBC=/usr/local
-    fi
-    ODBC_INCDIR=$PHP_UNIXODBC/include
-    ODBC_LIBDIR=$PHP_UNIXODBC/$PHP_LIBDIR
-    ODBC_LFLAGS=-L$ODBC_LIBDIR
-    ODBC_INCLUDE=-I$ODBC_INCDIR
-    ODBC_LIBS=-lodbc
-    ODBC_TYPE=unixODBC
-    PHP_ODBC_CHECK_HEADER(sqlext.h)
-    AC_DEFINE(HAVE_UNIXODBC,1,[ ])
-    AC_MSG_RESULT([$ext_output])
-  fi
-fi
-
-if test -z "$ODBC_TYPE"; then
-PHP_ARG_WITH(dbmaker,,
-[  --with-dbmaker[=DIR]    Include DBMaker support])
-
-  if test "$PHP_DBMAKER" != "no"; then
-    AC_MSG_CHECKING(for DBMaker support)
-    if test "$PHP_DBMAKER" = "yes"; then
-      # find dbmaker's home directory
-      DBMAKER_HOME=`grep "^dbmaker:" /etc/passwd | $AWK -F: '{print $6}'`
-
-      # check DBMaker version (from 5.0 to 2.0)
-      DBMAKER_VERSION=5.0
-
-      while test ! -d $DBMAKER_HOME/$DBMAKER_VERSION -a "$DBMAKER_VERSION" != "2.9"; do
-        DM_VER=`echo $DBMAKER_VERSION | sed -e 's/\.//' | $AWK '{ print $1-1;}'`
-        MAJOR_V=`echo $DM_VER | $AWK '{ print $1/10; }'  | $AWK -F. '{ print $1; }'`
-        MINOR_V=`echo $DM_VER | $AWK '{ print $1%10; }'`
-        DBMAKER_VERSION=$MAJOR_V.$MINOR_V
-      done
-
-      if test "$DBMAKER_VERSION" = "2.9"; then
-        PHP_DBMAKER=$DBMAKER_HOME
-      else
-        PHP_DBMAKER=$DBMAKER_HOME/$DBMAKER_VERSION
-      fi
-    fi
-
-    ODBC_INCDIR=$PHP_DBMAKER/include
-    ODBC_LIBDIR=$PHP_DBMAKER/$PHP_LIBDIR
-    ODBC_INCLUDE=-I$ODBC_INCDIR
-    ODBC_LFLAGS=-L$ODBC_LIBDIR
-    ODBC_INCLUDE=-I$ODBC_INCDIR
-    ODBC_LIBS="-ldmapic -lc"
-    ODBC_TYPE=dbmaker
-
-    AC_DEFINE(HAVE_DBMAKER,1,[Whether you want DBMaker])
-
-    if test "$ext_shared" = "yes"; then
-      AC_MSG_RESULT([yes (shared)])
-      ODBC_LIBS="-ldmapic -lc -lm"
-      ODBC_SHARED="odbc.la"
-    else
-      AC_MSG_RESULT([yes (static)])
-      PHP_ADD_LIBRARY_WITH_PATH(dmapic, $ODBC_LIBDIR)
-      PHP_ADD_INCLUDE($ODBC_INCDIR)
-      ODBC_STATIC="libphpext_odbc.la"
-    fi
-  fi
-fi
-
 dnl
 dnl Extension setup
 dnl
Index: 5_2_4/ext/iconv/config.m4
===================================================================
--- 5_2_4.orig/ext/iconv/config.m4
+++ 5_2_4/ext/iconv/config.m4
@@ -79,9 +79,24 @@ int main() {
       ])
     fi
 
+    if test -z "$iconv_impl_name"; then
+      AC_MSG_CHECKING([if using IBM iconv])
+      php_iconv_old_ld="$LDFLAGS"
+      LDFLAGS="-liconv $LDFLAGS"
+      AC_TRY_LINK([#include <iconv.h>],[cstoccsid("");],
+      [
+        AC_MSG_RESULT(yes)
+        iconv_impl_name="ibm"
+      ],[
+        AC_MSG_RESULT(no)
+        LDFLAGS="$php_iconv_old_ld"
+      ])
+    fi
+
     echo > ext/iconv/php_have_bsd_iconv.h
     echo > ext/iconv/php_have_glibc_iconv.h
     echo > ext/iconv/php_have_libiconv.h
+    echo > ext/iconv/php_have_ibm_iconv.h
 
     case "$iconv_impl_name" in
       gnu_libiconv [)]
@@ -104,6 +119,12 @@ int main() {
         PHP_DEFINE([PHP_ICONV_IMPL],[\"glibc\"],[ext/iconv])
         AC_DEFINE([PHP_ICONV_IMPL],["glibc"],[Which iconv implementation to use])
         ;;
+      ibm [)]
+        PHP_DEFINE([HAVE_IBM_ICONV],1,[ext/iconv])
+        AC_DEFINE([HAVE_IBM_ICONV],1,[IBM iconv implementation])
+        PHP_DEFINE([PHP_ICONV_IMPL],[\"IBM iconv\"],[ext/iconv])
+        AC_DEFINE([PHP_ICONV_IMPL],["IBM iconv"],[Which iconv implementation to use])
+        ;;
     esac
 
     AC_MSG_CHECKING([if iconv supports errno])
