--- php-5.2.10/Zend/zend_execute_API.c	2009-04-08 03:28:04.000000000 +0300
+++ php-5.2.10/Zend/zend_execute_API.c	2009-08-19 09:01:02.000000000 +0300
@@ -17,7 +17,7 @@
    +----------------------------------------------------------------------+
 */
 
-/* $Id: zend_execute_API.c,v 1.331.2.20.2.31 2009/04/08 00:28:04 felipe Exp $ */
+/* $Id$ */
 
 #include <stdio.h>
 #include <signal.h>
@@ -921,6 +921,12 @@
 	for (i=0; i<fci->param_count; i++) {
 		zval *param;
 
+		if(EX(function_state).function->type == ZEND_INTERNAL_FUNCTION
+			&& !ARG_SHOULD_BE_SENT_BY_REF(EX(function_state).function, i + 1)
+			&& PZVAL_IS_REF(*fci->params[i])) {
+			SEPARATE_ZVAL(fci->params[i]);
+		}
+
 		if (ARG_SHOULD_BE_SENT_BY_REF(EX(function_state).function, i+1)
 			&& !PZVAL_IS_REF(*fci->params[i])) {
 			if ((*fci->params[i])->refcount>1) {
--- php-5.2.10/Zend/zend_vm_def.h	2009-06-05 14:21:47.000000000 +0300
+++ php-5.2.10/Zend/zend_vm_def.h	2009-08-19 09:01:42.000000000 +0300
@@ -18,7 +18,7 @@
    +----------------------------------------------------------------------+
 */
 
-/* $Id: zend_vm_def.h,v 1.59.2.29.2.70 2009/06/05 11:21:47 lbarnaud Exp $ */
+/* $Id$ */
 
 /* If you change this file, please regenerate the zend_vm_execute.h and
  * zend_vm_opcodes.h files by running:
@@ -2371,6 +2371,10 @@
 		zend_error_noreturn(E_ERROR, "Only variables can be passed by reference");
 	}
 
+      	if (EX(function_state).function->type == ZEND_INTERNAL_FUNCTION && !ARG_SHOULD_BE_SENT_BY_REF(EX(fbc), opline->op2.u.opline_num)) {
+               ZEND_VM_DISPATCH_TO_HELPER(zend_send_by_var_helper);
+        }
+
 	SEPARATE_ZVAL_TO_MAKE_IS_REF(varptr_ptr);
 	varptr = *varptr_ptr;
 	varptr->refcount++;
@@ -3196,15 +3200,22 @@
 			ALLOC_ZVAL(tmp);
 			INIT_PZVAL_COPY(tmp, array_ptr);
 			array_ptr = tmp;
+			if (Z_TYPE_P(array_ptr) == IS_OBJECT) {
+				ce = Z_OBJCE_P(array_ptr);
+				if (ce && ce->get_iterator) {
+					array_ptr->refcount--;
+				}
+			}
 		} else if (Z_TYPE_P(array_ptr) == IS_OBJECT) {
 			ce = Z_OBJCE_P(array_ptr);
 			if (!ce || !ce->get_iterator) {
 				array_ptr->refcount++;
 			}
 		} else {
-			if ((OP1_TYPE == IS_CV || OP1_TYPE == IS_VAR) &&
+			if (OP1_TYPE == IS_CONST ||
+			    ((OP1_TYPE == IS_CV || OP1_TYPE == IS_VAR) &&
 			    !array_ptr->is_ref &&
-			    array_ptr->refcount > 1) {
+			    array_ptr->refcount > 1)) {
 				zval *tmp;
 
 				ALLOC_ZVAL(tmp);
@@ -3217,7 +3228,7 @@
 		}
 	}
 
-	if (OP1_TYPE != IS_TMP_VAR && ce && ce->get_iterator) {
+	if (ce && ce->get_iterator) {
 		iter = ce->get_iterator(ce, array_ptr, opline->extended_value & ZEND_FE_RESET_REFERENCE TSRMLS_CC);
 
 		if (iter && !EG(exception)) {
--- php-5.2.10/Zend/zend_vm_execute.h	2009-06-05 14:21:47.000000000 +0300
+++ php-5.2.10/Zend/zend_vm_execute.h	2009-08-19 09:17:03.000000000 +0300
@@ -2230,15 +2230,22 @@
 			ALLOC_ZVAL(tmp);
 			INIT_PZVAL_COPY(tmp, array_ptr);
 			array_ptr = tmp;
+			if (Z_TYPE_P(array_ptr) == IS_OBJECT) {
+				ce = Z_OBJCE_P(array_ptr);
+				if (ce && ce->get_iterator) {
+					array_ptr->refcount--;
+				}
+			}
 		} else if (Z_TYPE_P(array_ptr) == IS_OBJECT) {
 			ce = Z_OBJCE_P(array_ptr);
 			if (!ce || !ce->get_iterator) {
 				array_ptr->refcount++;
 			}
 		} else {
-			if ((IS_CONST == IS_CV || IS_CONST == IS_VAR) &&
+			if (IS_CONST == IS_CONST ||
+			    ((IS_CONST == IS_CV || IS_CONST == IS_VAR) &&
 			    !array_ptr->is_ref &&
-			    array_ptr->refcount > 1) {
+			    array_ptr->refcount > 1)) {
 				zval *tmp;
 
 				ALLOC_ZVAL(tmp);
@@ -2251,7 +2258,7 @@
 		}
 	}
 
-	if (IS_CONST != IS_TMP_VAR && ce && ce->get_iterator) {
+	if (ce && ce->get_iterator) {
 		iter = ce->get_iterator(ce, array_ptr, opline->extended_value & ZEND_FE_RESET_REFERENCE TSRMLS_CC);
 
 		if (iter && !EG(exception)) {
@@ -4805,15 +4812,22 @@
 			ALLOC_ZVAL(tmp);
 			INIT_PZVAL_COPY(tmp, array_ptr);
 			array_ptr = tmp;
+			if (Z_TYPE_P(array_ptr) == IS_OBJECT) {
+				ce = Z_OBJCE_P(array_ptr);
+				if (ce && ce->get_iterator) {
+					array_ptr->refcount--;
+				}
+			}
 		} else if (Z_TYPE_P(array_ptr) == IS_OBJECT) {
 			ce = Z_OBJCE_P(array_ptr);
 			if (!ce || !ce->get_iterator) {
 				array_ptr->refcount++;
 			}
 		} else {
-			if ((IS_TMP_VAR == IS_CV || IS_TMP_VAR == IS_VAR) &&
+			if (IS_TMP_VAR == IS_CONST ||
+			    ((IS_TMP_VAR == IS_CV || IS_TMP_VAR == IS_VAR) &&
 			    !array_ptr->is_ref &&
-			    array_ptr->refcount > 1) {
+			    array_ptr->refcount > 1)) {
 				zval *tmp;
 
 				ALLOC_ZVAL(tmp);
@@ -4826,7 +4840,7 @@
 		}
 	}
 
-	if (IS_TMP_VAR != IS_TMP_VAR && ce && ce->get_iterator) {
+	if (ce && ce->get_iterator) {
 		iter = ce->get_iterator(ce, array_ptr, opline->extended_value & ZEND_FE_RESET_REFERENCE TSRMLS_CC);
 
 		if (iter && !EG(exception)) {
@@ -7570,6 +7584,10 @@
 		zend_error_noreturn(E_ERROR, "Only variables can be passed by reference");
 	}
 
+      	if (EX(function_state).function->type == ZEND_INTERNAL_FUNCTION && !ARG_SHOULD_BE_SENT_BY_REF(EX(fbc), opline->op2.u.opline_num)) {
+               return zend_send_by_var_helper_SPEC_VAR(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
+        }
+
 	SEPARATE_ZVAL_TO_MAKE_IS_REF(varptr_ptr);
 	varptr = *varptr_ptr;
 	varptr->refcount++;
@@ -7954,15 +7972,22 @@
 			ALLOC_ZVAL(tmp);
 			INIT_PZVAL_COPY(tmp, array_ptr);
 			array_ptr = tmp;
+			if (Z_TYPE_P(array_ptr) == IS_OBJECT) {
+				ce = Z_OBJCE_P(array_ptr);
+				if (ce && ce->get_iterator) {
+					array_ptr->refcount--;
+				}
+			}
 		} else if (Z_TYPE_P(array_ptr) == IS_OBJECT) {
 			ce = Z_OBJCE_P(array_ptr);
 			if (!ce || !ce->get_iterator) {
 				array_ptr->refcount++;
 			}
 		} else {
-			if ((IS_VAR == IS_CV || IS_VAR == IS_VAR) &&
+			if (IS_VAR == IS_CONST ||
+			    ((IS_VAR == IS_CV || IS_VAR == IS_VAR) &&
 			    !array_ptr->is_ref &&
-			    array_ptr->refcount > 1) {
+			    array_ptr->refcount > 1)) {
 				zval *tmp;
 
 				ALLOC_ZVAL(tmp);
@@ -7975,7 +8000,7 @@
 		}
 	}
 
-	if (IS_VAR != IS_TMP_VAR && ce && ce->get_iterator) {
+	if (ce && ce->get_iterator) {
 		iter = ce->get_iterator(ce, array_ptr, opline->extended_value & ZEND_FE_RESET_REFERENCE TSRMLS_CC);
 
 		if (iter && !EG(exception)) {
@@ -19988,6 +20013,10 @@
 		zend_error_noreturn(E_ERROR, "Only variables can be passed by reference");
 	}
 
+      	if (EX(function_state).function->type == ZEND_INTERNAL_FUNCTION && !ARG_SHOULD_BE_SENT_BY_REF(EX(fbc), opline->op2.u.opline_num)) {
+               return zend_send_by_var_helper_SPEC_CV(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
+        }
+
 	SEPARATE_ZVAL_TO_MAKE_IS_REF(varptr_ptr);
 	varptr = *varptr_ptr;
 	varptr->refcount++;
@@ -20364,15 +20393,22 @@
 			ALLOC_ZVAL(tmp);
 			INIT_PZVAL_COPY(tmp, array_ptr);
 			array_ptr = tmp;
+			if (Z_TYPE_P(array_ptr) == IS_OBJECT) {
+				ce = Z_OBJCE_P(array_ptr);
+				if (ce && ce->get_iterator) {
+					array_ptr->refcount--;
+				}
+			}
 		} else if (Z_TYPE_P(array_ptr) == IS_OBJECT) {
 			ce = Z_OBJCE_P(array_ptr);
 			if (!ce || !ce->get_iterator) {
 				array_ptr->refcount++;
 			}
 		} else {
-			if ((IS_CV == IS_CV || IS_CV == IS_VAR) &&
+			if (IS_CV == IS_CONST ||
+			    ((IS_CV == IS_CV || IS_CV == IS_VAR) &&
 			    !array_ptr->is_ref &&
-			    array_ptr->refcount > 1) {
+			    array_ptr->refcount > 1)) {
 				zval *tmp;
 
 				ALLOC_ZVAL(tmp);
@@ -20385,7 +20421,7 @@
 		}
 	}
 
-	if (IS_CV != IS_TMP_VAR && ce && ce->get_iterator) {
+	if (ce && ce->get_iterator) {
 		iter = ce->get_iterator(ce, array_ptr, opline->extended_value & ZEND_FE_RESET_REFERENCE TSRMLS_CC);
 
 		if (iter && !EG(exception)) {
--- php-5.2.10/ext/standard/array.c	2009-05-15 20:03:43.000000000 +0300
+++ php-5.2.10/ext/standard/array.c	2009-08-19 09:32:34.000000000 +0300
@@ -21,7 +21,7 @@
    +----------------------------------------------------------------------+
 */
 
-/* $Id: array.c,v 1.308.2.21.2.67 2009/05/15 17:03:43 moriyoshi Exp $ */
+/* $Id$ */
 
 #include "php.h"
 #include "php_ini.h"
@@ -657,6 +657,7 @@
 PHP_FUNCTION(usort)
 {
 	zval **array;
+	int refcount;
 	HashTable *target_hash;
 	PHP_ARRAY_CMP_FUNC_VARS;
 
@@ -678,12 +679,31 @@
 	PHP_ARRAY_CMP_FUNC_CHECK(BG(user_compare_func_name))
 	BG(user_compare_fci_cache).initialized = 0;
 	
+	/* Clear the is_ref flag, so the attemts to modify the array in user
+	 * comaprison function will create a copy of array and won't affect the
+	 * original array. The fact of modification is detected using refcount
+	 * comparison. The result of sorting in such case is undefined and the
+	 * function returns FALSE.
+	 */
+	(*array)->is_ref = 0;
+	refcount = (*array)->refcount;
+
 	if (zend_hash_sort(target_hash, zend_qsort, array_user_compare, 1 TSRMLS_CC) == FAILURE) {
-		PHP_ARRAY_CMP_FUNC_RESTORE();
-		RETURN_FALSE;
+		RETVAL_FALSE;
+	} else {
+		if (refcount > (*array)->refcount) {
+			php_error_docref(NULL TSRMLS_CC, E_WARNING, "Array was modified by the user comparison function");
+			RETVAL_FALSE;
+		} else {
+			RETVAL_TRUE;
+		}
+	}
+
+	if ((*array)->refcount > 1) {
+		(*array)->is_ref = 1;
 	}
+	
 	PHP_ARRAY_CMP_FUNC_RESTORE();
-	RETURN_TRUE;
 }
 /* }}} */
 
@@ -692,6 +712,7 @@
 PHP_FUNCTION(uasort)
 {
 	zval **array;
+	int refcount;
 	HashTable *target_hash;
 	PHP_ARRAY_CMP_FUNC_VARS;
 
@@ -711,13 +732,31 @@
 	PHP_ARRAY_CMP_FUNC_CHECK(BG(user_compare_func_name))
 	BG(user_compare_fci_cache).initialized = 0;
 
+	/* Clear the is_ref flag, so the attemts to modify the array in user
+	 * comaprison function will create a copy of array and won't affect the
+	 * original array. The fact of modification is detected using refcount
+	 * comparison. The result of sorting in such case is undefined and the
+	 * function returns FALSE.
+	 */
+	(*array)->is_ref = 0;
+	refcount = (*array)->refcount;
+
 	if (zend_hash_sort(target_hash, zend_qsort, array_user_compare, 0 TSRMLS_CC) == FAILURE) {
-		PHP_ARRAY_CMP_FUNC_RESTORE();
-		RETURN_FALSE;
+		RETVAL_FALSE;
+	} else {
+		if (refcount > (*array)->refcount) {
+			php_error_docref(NULL TSRMLS_CC, E_WARNING, "Array was modified by the user comparison function");
+			RETVAL_FALSE;
+		} else {
+			RETVAL_TRUE;
+		}
 	}
-	PHP_ARRAY_CMP_FUNC_RESTORE();
 
-	RETURN_TRUE;
+	if ((*array)->refcount > 1) {
+		(*array)->is_ref = 1;
+	}
+
+	PHP_ARRAY_CMP_FUNC_RESTORE();
 }
 /* }}} */
 
