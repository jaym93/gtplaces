Index: 5_2_2/sapi/apache/mod_php5.c
===================================================================
--- 5_2_2.orig/sapi/apache/mod_php5.c
+++ 5_2_2/sapi/apache/mod_php5.c
@@ -22,6 +22,8 @@
 #include "php_apache_http.h"
 #include "http_conf_globals.h"
 
+#include "ext/apollo/php_apollo.h"
+
 #ifdef NETWARE
 #define SIGPIPE SIGINT
 #endif
@@ -943,6 +945,7 @@ static void php_init_handler(server_rec 
 	{
 		TSRMLS_FETCH();
 		if (PG(expose_php)) {
+			ap_add_version_component("Zend Core/" APOLLO_VERSION);
 			ap_add_version_component("PHP/" PHP_VERSION);
 		}
 	}
Index: 5_2_2/sapi/apache2handler/sapi_apache2.c
===================================================================
--- 5_2_2.orig/sapi/apache2handler/sapi_apache2.c
+++ 5_2_2/sapi/apache2handler/sapi_apache2.c
@@ -53,6 +53,8 @@
 
 #include "php_apache.h"
 
+#include "ext/apollo/php_apollo.h"
+
 /* UnixWare and Netware define shutdown to _shutdown, which causes problems later
  * on when using a structure member named shutdown. Since this source
  * file does not use the system call shutdown, it is safe to #undef it.K
@@ -364,6 +366,7 @@ static void php_apache_add_version(apr_p
 {
 	TSRMLS_FETCH();
 	if (PG(expose_php)) {
+		ap_add_version_component(p, "Zend Core/" APOLLO_VERSION);
 		ap_add_version_component(p, "PHP/" PHP_VERSION);
 	}
 }
Index: 5_2_2/sapi/cgi/cgi_main.c
===================================================================
--- 5_2_2.orig/sapi/cgi/cgi_main.c
+++ 5_2_2/sapi/cgi/cgi_main.c
@@ -141,6 +141,7 @@ static const opt_struct OPTIONS[] = {
 	{'?', 0, "usage"},/* help alias (both '?' and 'usage') */
 	{'v', 0, "version"},
 	{'z', 1, "zend-extension"},
+ 	{'R', 1, "repeat"},
 	{'-', 0, NULL} /* end of args */
 };
 
@@ -1123,6 +1124,9 @@ int main(int argc, char *argv[])
 	int status = 0;
 #endif
 #endif /* PHP_FASTCGI */
+	int benchmark = 0;
+	int repeats = 1;
+	struct timeval start, end;
 
 #if 0 && defined(PHP_DEBUG)
 	/* IIS is always making things more difficult.  This allows
@@ -1414,8 +1418,15 @@ consult the installation file that came 
 	zend_first_try {
 		while ((c = php_getopt(argc, argv, OPTIONS, &php_optarg, &php_optind, 1)) != -1) {
 			switch (c) {
+				case 'R': 
+				        benchmark = 1;
+						repeats = atoi(php_optarg);
+						break;
 				case 'h':
 				case '?':
+#if PHP_FASTCGI
+					fcgi_shutdown();
+#endif
 					no_headers = 1;
 					php_output_startup();
 					php_output_activate(TSRMLS_C);
@@ -1428,6 +1439,9 @@ consult the installation file that came 
 		}
 		php_optind = orig_optind;
 		php_optarg = orig_optarg;
+		if (benchmark) {
+			gettimeofday(&start, NULL);
+		}
 
 #if PHP_FASTCGI
 		/* start of FAST CGI loop */
@@ -1797,19 +1811,24 @@ fastcgi_request_done:
 
 		}
 
+		repeats--;
 #if PHP_FASTCGI
-			if (!fastcgi) break;
+			if (!fastcgi && repeats <= 0) break;
 			/* only fastcgi will get here */
 			requests++;
-			if (max_requests && (requests == max_requests)) {
+			if (fastcgi && max_requests && (requests == max_requests)) {
 				fcgi_finish_request(&request);
 				if (bindpath) {
 					free(bindpath);
 				}
 				break;
 			}
+			php_optind = orig_optind;
+			php_optarg = orig_optarg;
+
 			/* end of fastcgi loop */
 		}
+		fcgi_shutdown();
 #endif
 
 		if (cgi_sapi_module.php_ini_path_override) {
@@ -1822,6 +1841,18 @@ fastcgi_request_done:
 		exit_status = 255;
 	} zend_end_try();
 
+	if (benchmark) {
+		gettimeofday(&end, NULL);
+		end.tv_sec -= start.tv_sec;
+		if (end.tv_usec >= start.tv_usec) {
+			end.tv_usec -= start.tv_usec;
+		} else {
+			end.tv_sec -= 1;
+			end.tv_usec = end.tv_usec + 1000000 - start.tv_usec;
+		}
+		fprintf(stderr, "\nElapsed time: %d.%06d sec\n", end.tv_sec, start.tv_usec);
+	}
+
 	SG(server_context) = NULL;
 	php_module_shutdown(TSRMLS_C);
 	sapi_shutdown();
Index: 5_2_2/Zend/zend_execute.c
===================================================================
--- 5_2_2.orig/Zend/zend_execute.c
+++ 5_2_2/Zend/zend_execute.c
@@ -732,10 +732,11 @@ static inline void zend_assign_to_variab
  			if (variable_ptr != value) {
  				zend_uint refcount = variable_ptr->refcount;
  				zval garbage;
- 
+#ifndef ZEND_WIN32
  				if (type != IS_TMP_VAR) {
  					value->refcount++;
  				}
+#endif
  				garbage = *variable_ptr;
  				*variable_ptr = *value;
  				variable_ptr->refcount = refcount;
@@ -743,7 +744,9 @@ static inline void zend_assign_to_variab
  				zend_error(E_STRICT, "Implicit cloning object of class '%s' because of 'zend.ze1_compatibility_mode'", class_name);
  				variable_ptr->value.obj = Z_OBJ_HANDLER_P(value, clone_obj)(value TSRMLS_CC);
  				if (type != IS_TMP_VAR) {
+#ifndef ZEND_WIN32
  					value->refcount--;
+#endif
  				}
  				zendi_zval_dtor(garbage);
  			}
@@ -771,17 +774,20 @@ static inline void zend_assign_to_variab
 		if (variable_ptr!=value) {
 			zend_uint refcount = variable_ptr->refcount;
 			zval garbage;
-
+#ifndef ZEND_WIN32
 			if (type!=IS_TMP_VAR) {
 				value->refcount++;
 			}
+#endif
 			garbage = *variable_ptr;
 			*variable_ptr = *value;
 			variable_ptr->refcount = refcount;
 			variable_ptr->is_ref = 1;
 			if (type!=IS_TMP_VAR) {
 				zendi_zval_copy_ctor(*variable_ptr);
+#ifndef ZEND_WIN32
 				value->refcount--;
+#endif
 			}
 			zendi_zval_dtor(garbage);
 		}
Index: 5_2_2/ext/openssl/openssl.c
===================================================================
--- 5_2_2.orig/ext/openssl/openssl.c
+++ 5_2_2/ext/openssl/openssl.c
@@ -1541,13 +1541,13 @@ cleanup:
 }
 /* }}} */
 
-/* {{{ proto bool openssl_pkcs12_read(mixed PKCS12, array &certs, string pass)
+/* {{{ proto bool openssl_pkcs12_read(string PKCS12, array &certs, string pass)
    Parses a PKCS12 to an array */
 PHP_FUNCTION(openssl_pkcs12_read)
 {
-	zval *zp12 = NULL, *zout = NULL, *zextracerts, *zcert, *zpkey;
-	char * pass;
-	int pass_len;
+	zval *zout = NULL, *zextracerts, *zcert, *zpkey;
+	char *pass, *zp12;
+	int pass_len, zp12_len;
 	PKCS12 * p12 = NULL;
 	EVP_PKEY * pkey = NULL;
 	X509 * cert = NULL;
@@ -1555,14 +1555,14 @@ PHP_FUNCTION(openssl_pkcs12_read)
 	BIO * bio_in = NULL;
 	int i;
 
-	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzs", &zp12, &zout, &pass, &pass_len) == FAILURE)
+	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "szs", &zp12, &zp12_len, &zout, &pass, &pass_len) == FAILURE)
 		return;
 
 	RETVAL_FALSE;
 	
 	bio_in = BIO_new(BIO_s_mem());
 	
-	if(!BIO_write(bio_in, Z_STRVAL_P(zp12), Z_STRLEN_P(zp12)))
+	if(!BIO_write(bio_in, zp12, zp12_len))
 		goto cleanup;
 	
 	if(d2i_PKCS12_bio(bio_in, &p12)) {
Index: 5_2_2/ext/filter/logical_filters.c
===================================================================
--- 5_2_2.orig/ext/filter/logical_filters.c
+++ 5_2_2/ext/filter/logical_filters.c
@@ -469,7 +469,7 @@ void php_filter_validate_url(PHP_INPUT_F
 void php_filter_validate_email(PHP_INPUT_FILTER_PARAM_DECL) /* {{{ */
 {
 	/* From http://cvs.php.net/co.php/pear/HTML_QuickForm/QuickForm/Rule/Email.php?r=1.4 */
-	const char regexp[] = "/^((\\\"[^\\\"\\f\\n\\r\\t\\b]+\\\")|([\\w\\!\\#\\$\\%\\&\\'\\*\\+\\-\\~\\/\\^\\`\\|\\{\\}]+(\\.[\\w\\!\\#\\$\\%\\&\\'\\*\\+\\-\\~\\/\\^\\`\\|\\{\\}]+)*))@((\\[(((25[0-5])|(2[0-4][0-9])|([0-1]?[0-9]?[0-9]))\\.((25[0-5])|(2[0-4][0-9])|([0-1]?[0-9]?[0-9]))\\.((25[0-5])|(2[0-4][0-9])|([0-1]?[0-9]?[0-9]))\\.((25[0-5])|(2[0-4][0-9])|([0-1]?[0-9]?[0-9])))\\])|(((25[0-5])|(2[0-4][0-9])|([0-1]?[0-9]?[0-9]))\\.((25[0-5])|(2[0-4][0-9])|([0-1]?[0-9]?[0-9]))\\.((25[0-5])|(2[0-4][0-9])|([0-1]?[0-9]?[0-9]))\\.((25[0-5])|(2[0-4][0-9])|([0-1]?[0-9]?[0-9])))|((([A-Za-z0-9\\-])+\\.)+[A-Za-z\\-]+))$/";
+	const char regexp[] = "/^((\\\"[^\\\"\\f\\n\\r\\t\\b]+\\\")|([\\w\\!\\#\\$\\%\\&\\'\\*\\+\\-\\~\\/\\^\\`\\|\\{\\}]+(\\.[\\w\\!\\#\\$\\%\\&\\'\\*\\+\\-\\~\\/\\^\\`\\|\\{\\}]+)*))@((\\[(((25[0-5])|(2[0-4][0-9])|([0-1]?[0-9]?[0-9]))\\.((25[0-5])|(2[0-4][0-9])|([0-1]?[0-9]?[0-9]))\\.((25[0-5])|(2[0-4][0-9])|([0-1]?[0-9]?[0-9]))\\.((25[0-5])|(2[0-4][0-9])|([0-1]?[0-9]?[0-9])))\\])|(((25[0-5])|(2[0-4][0-9])|([0-1]?[0-9]?[0-9]))\\.((25[0-5])|(2[0-4][0-9])|([0-1]?[0-9]?[0-9]))\\.((25[0-5])|(2[0-4][0-9])|([0-1]?[0-9]?[0-9]))\\.((25[0-5])|(2[0-4][0-9])|([0-1]?[0-9]?[0-9])))|((([A-Za-z0-9\\-])+\\.)+[A-Za-z\\-]+))$/D";
 
 	pcre       *re = NULL;
 	pcre_extra *pcre_extra = NULL;
Index: 5_2_2/ext/standard/string.c
===================================================================
--- 5_2_2.orig/ext/standard/string.c
+++ 5_2_2/ext/standard/string.c
@@ -1856,7 +1856,7 @@ PHP_FUNCTION(strripos)
 			e = haystack + haystack_len - 1;
 		} else {
 			p = haystack;
-			if (-offset > haystack_len) {
+			if (-offset > haystack_len || -offset < 0) {
 				php_error_docref(NULL TSRMLS_CC, E_NOTICE, "Offset is greater than the length of haystack string");
 				RETURN_FALSE;
 			} else {
@@ -1889,7 +1889,7 @@ PHP_FUNCTION(strripos)
 		p = haystack_dup + offset;
 		e = haystack_dup + haystack_len - needle_len;
 	} else {
-		if (-offset > haystack_len) {
+		if (-offset > haystack_len || -offset < 0) {
 			efree(needle_dup);
 			efree(haystack_dup);
 			php_error_docref(NULL TSRMLS_CC, E_NOTICE, "Offset is greater than the length of haystack string");
Index: 5_2_2/ext/standard/dns.c
===================================================================
--- 5_2_2.orig/ext/standard/dns.c
+++ 5_2_2/ext/standard/dns.c
@@ -264,6 +264,10 @@ PHP_FUNCTION(dns_check_record)
 			}
 			type = T_MX;
 			convert_to_string_ex(arg1);
+			if (Z_STRLEN_PP(arg1) == 0) {
+				php_error_docref(NULL TSRMLS_CC, E_WARNING, "Host cannot be empty");
+				RETURN_FALSE;
+			}
 			break;
 
 		case 2:
@@ -273,6 +277,11 @@ PHP_FUNCTION(dns_check_record)
 			convert_to_string_ex(arg1);
 			convert_to_string_ex(arg2);
 
+			if (Z_STRLEN_PP(arg1) == 0 || Z_STRLEN_PP(arg2) == 0) {
+				php_error_docref(NULL TSRMLS_CC, E_WARNING, "Host and type cannot be empty");
+				RETURN_FALSE;
+			}
+
 			if (!strcasecmp("A", Z_STRVAL_PP(arg2))) type = T_A;
 			else if (!strcasecmp("NS",    Z_STRVAL_PP(arg2))) type = DNS_T_NS;
 			else if (!strcasecmp("MX",    Z_STRVAL_PP(arg2))) type = DNS_T_MX;
Index: 5_2_2/ext/standard/iptc.c
===================================================================
--- 5_2_2.orig/ext/standard/iptc.c
+++ 5_2_2/ext/standard/iptc.c
@@ -212,16 +212,16 @@ PHP_FUNCTION(iptcembed)
 
 	if (php_iptc_get1(fp, spool, poi?&poi:0 TSRMLS_CC) != 0xFF) {
 		fclose(fp);
-		if (poi) {
-			efree(poi);
+		if (spoolbuf) {
+			efree(spoolbuf);
 		}
 		RETURN_FALSE;
 	}
 
 	if (php_iptc_get1(fp, spool, poi?&poi:0 TSRMLS_CC) != 0xD8) {
 		fclose(fp);
-		if (poi) {
-			efree(poi);
+		if (spoolbuf) {
+			efree(spoolbuf);
 		}
 		RETURN_FALSE;
 	}
Index: 5_2_2/main/php_content_types.c
===================================================================
--- 5_2_2.orig/main/php_content_types.c
+++ 5_2_2/main/php_content_types.c
@@ -37,21 +37,21 @@ static sapi_post_entry php_post_entries[
  */
 SAPI_API SAPI_POST_READER_FUNC(php_default_post_reader)
 {
-	char *data = NULL;
-	int length = 0;
+	char *data;
+	int length;
 
 	/* $HTTP_RAW_POST_DATA registration */
-	if(!strcmp(SG(request_info).request_method, "POST")) {
-		if(NULL == SG(request_info).post_entry && SG(request_info).post_data) {
+	if (!strcmp(SG(request_info).request_method, "POST")) {
+		if (NULL == SG(request_info).post_entry) {
 			/* no post handler registered, so we just swallow the data */
 			sapi_read_standard_form_data(TSRMLS_C);
+		}
+
+		/* For unknown content types we create HTTP_RAW_POST_DATA even if always_populate_raw_post_data off,
+		 * this is in-effecient, but we need to keep doing it for BC reasons (for now) */
+		if ((PG(always_populate_raw_post_data) || NULL == SG(request_info).post_entry) && SG(request_info).post_data) {
 			length = SG(request_info).post_data_length;
 			data = estrndup(SG(request_info).post_data, length);
-		} else if(PG(always_populate_raw_post_data) && SG(request_info).post_data) {
-			length = SG(request_info).post_data_length;
-			data = estrndup(SG(request_info).post_data, length);
-		}
-		if(data) {
 			SET_VAR_STRINGL("HTTP_RAW_POST_DATA", data, length);
 		}
 	}
@@ -62,11 +62,10 @@ SAPI_API SAPI_POST_READER_FUNC(php_defau
 	 in the long run post handlers should be changed to not touch
 	 request_info.post_data for memory preservation reasons
 	*/
-	if(SG(request_info).post_data) {
+	if (SG(request_info).post_data) {
 		SG(request_info).raw_post_data = estrndup(SG(request_info).post_data, SG(request_info).post_data_length);
 		SG(request_info).raw_post_data_length = SG(request_info).post_data_length;
 	}
-
 }
 /* }}} */
 
Index: 5_2_2/ext/soap/php_http.c
===================================================================
--- 5_2_2.orig/ext/soap/php_http.c
+++ 5_2_2/ext/soap/php_http.c
@@ -22,6 +22,7 @@
 #include "php_soap.h"
 #include "ext/standard/base64.h"
 #include "ext/standard/md5.h"
+#include "ext/standard/php_rand.h"
 
 static char *get_http_header_value(char *headers, char *type);
 static int get_http_body(php_stream *socketd, int close, char *headers,  char **response, int *out_size TSRMLS_DC);
@@ -469,10 +470,9 @@ try_again:
 					char          HA1[33], HA2[33], response[33], cnonce[33], nc[9];
 					PHP_MD5_CTX   md5ctx;
 					unsigned char hash[16];
-					unsigned int ctx;
 
 					PHP_MD5Init(&md5ctx);
-					snprintf(cnonce, sizeof(cnonce), "%d", php_rand_r(&ctx));
+					snprintf(cnonce, sizeof(cnonce), "%ld", php_rand(TSRMLS_C));
 					PHP_MD5Update(&md5ctx, (unsigned char*)cnonce, strlen(cnonce));
 					PHP_MD5Final(hash, &md5ctx);
 					make_digest(cnonce, hash);
Index: 5_2_2/ext/sqlite/sess_sqlite.c
===================================================================
--- 5_2_2.orig/ext/sqlite/sess_sqlite.c
+++ 5_2_2/ext/sqlite/sess_sqlite.c
@@ -110,9 +110,13 @@ PS_READ_FUNC(sqlite) 
 		case SQLITE_ROW:
 			if (rowdata[0] != NULL) {
 				*vallen = strlen(rowdata[0]);
-				*val = emalloc(*vallen);
-				*vallen = sqlite_decode_binary(rowdata[0], *val);
-				(*val)[*vallen] = '\0';
+				if (*vallen) {
+					*val = emalloc(*vallen);
+					*vallen = sqlite_decode_binary(rowdata[0], *val);
+					(*val)[*vallen] = '\0';
+				} else {
+					*val = STR_EMPTY_ALLOC();
+				}
 			}
 			break;
 		default:
Index: 5_2_2/ext/session/session.c
===================================================================
--- 5_2_2.orig/ext/session/session.c
+++ 5_2_2/ext/session/session.c
@@ -1283,8 +1283,10 @@ PHPAPI void php_session_start(TSRMLS_D)
 		char *q;
 
 		p += lensess + 1;
-		if ((q = strpbrk(p, "/?\\")))
+		if ((q = strpbrk(p, "/?\\"))) {
 			PS(id) = estrndup(p, q - p);
+			PS(send_cookie) = 0;
+		}
 	}
 
 	/* check whether the current request was referred to by
Index: 5_2_2/ext/gd/libgd/gd_png.c
===================================================================
--- 5_2_2.orig/ext/gd/libgd/gd_png.c
+++ 5_2_2/ext/gd/libgd/gd_png.c
@@ -71,7 +71,11 @@ static void gdPngErrorHandler (png_struc
 
 static void gdPngReadData (png_structp png_ptr, png_bytep data, png_size_t length)
 {
-	gdGetBuf(data, length, (gdIOCtx *) png_get_io_ptr(png_ptr));
+	int check;
+	check = gdGetBuf(data, length, (gdIOCtx *) png_get_io_ptr(png_ptr));
+	if (check != length) {
+		png_error(png_ptr, "Read Error: truncated data");
+	}
 }
 
 static void gdPngWriteData (png_structp png_ptr, png_bytep data, png_size_t length)
Index: 5_2_2/ext/json/JSON_parser.c
===================================================================
--- 5_2_2.orig/ext/json/JSON_parser.c
+++ 5_2_2/ext/json/JSON_parser.c
@@ -288,7 +288,7 @@ static void json_create_zval(zval **z, s
     }
     else if (type == IS_DOUBLE)
     {
-        ZVAL_DOUBLE(*z, atof(buf->c));
+        ZVAL_DOUBLE(*z, zend_strtod(buf->c, NULL));
     }
     else if (type == IS_STRING)
     {
@@ -357,14 +357,14 @@ static void attach_zval(json_parser *jso
     {
         if (!assoc)
         {
-            add_property_zval_ex(root, (key->len ? key->c : "_empty_"), (key->len ? (key->len + 1) : sizeof("_empty_")), child TSRMLS_CC);
+            add_property_zval_ex(root, (key->len ? key->c : ""), (key->len ? (key->len + 1) : sizeof("")), child TSRMLS_CC);
 #if PHP_MAJOR_VERSION >= 5
             ZVAL_DELREF(child);
 #endif
         }
         else
         {
-            add_assoc_zval_ex(root, (key->len ? key->c : "_empty_"), (key->len ? (key->len + 1) : sizeof("_empty_")), child);
+            add_assoc_zval_ex(root, (key->len ? key->c : ""), (key->len ? (key->len + 1) : sizeof("")), child);
         }
         key->len = 0;
     }
@@ -500,14 +500,14 @@ JSON_parser(zval *z, unsigned short p[],
 
                     if (!assoc)
                     {
-                        add_property_zval_ex(JSON(the_zstack)[JSON(the_top)], (key.len ? key.c : "_empty_"), (key.len ? (key.len + 1) : sizeof("_empty_")), mval TSRMLS_CC);
+                        add_property_zval_ex(JSON(the_zstack)[JSON(the_top)], (key.len ? key.c : ""), (key.len ? (key.len + 1) : sizeof("")), mval TSRMLS_CC);
 #if PHP_MAJOR_VERSION >= 5
                         ZVAL_DELREF(mval);
 #endif
                     }
                     else
                     {
-                        add_assoc_zval_ex(JSON(the_zstack)[JSON(the_top)], (key.len ? key.c : "_empty_"), (key.len ? (key.len + 1) : sizeof("_empty_")), mval);
+                        add_assoc_zval_ex(JSON(the_zstack)[JSON(the_top)], (key.len ? key.c : ""), (key.len ? (key.len + 1) : sizeof("")), mval);
                     }
                     key.len = 0;
                     buf.len = 0;
@@ -631,14 +631,14 @@ JSON_parser(zval *z, unsigned short p[],
                             {
                                 if (!assoc)
                                 {
-                                    add_property_zval_ex(JSON(the_zstack)[JSON(the_top)], (key.len ? key.c : "_empty_"), (key.len ? (key.len + 1) : sizeof("_empty_")), mval TSRMLS_CC);
+                                    add_property_zval_ex(JSON(the_zstack)[JSON(the_top)], (key.len ? key.c : ""), (key.len ? (key.len + 1) : sizeof("")), mval TSRMLS_CC);
 #if PHP_MAJOR_VERSION >= 5
                                     ZVAL_DELREF(mval);
 #endif
                                 }
                                 else
                                 {
-                                    add_assoc_zval_ex(JSON(the_zstack)[JSON(the_top)], (key.len ? key.c : "_empty_"), (key.len ? (key.len + 1) : sizeof("_empty_")), mval);
+                                    add_assoc_zval_ex(JSON(the_zstack)[JSON(the_top)], (key.len ? key.c : ""), (key.len ? (key.len + 1) : sizeof("")), mval);
                                 }
                                 key.len = 0;
                             }
Index: 5_2_2/ext/dbase/dbf_head.c
===================================================================
--- 5_2_2.orig/ext/dbase/dbf_head.c
+++ 5_2_2/ext/dbase/dbf_head.c
@@ -184,7 +184,7 @@ int put_dbf_field(dbhead_t *dbh, dbfield
 	/* build the on disk field info */
 	scp = dbf->db_fname; dcp = dbfield.dbf_name;
 
-	strlcpy(dbfield.dbf_name, dbf->db_fname, DBF_NAMELEN);
+	strlcpy(dbfield.dbf_name, dbf->db_fname, DBF_NAMELEN + 1);
 
 	dbfield.dbf_type = dbf->db_type;
 	switch (dbf->db_type) {
@@ -215,7 +215,7 @@ void put_dbf_info(dbhead_t *dbh)
 	int		fcnt;
 
 	if ((cp = db_cur_date(NULL))) {
-		strlcpy(dbh->db_date, cp, 8);
+		strlcpy(dbh->db_date, cp, 9);
 		free(cp);
 	}
 	put_dbf_head(dbh);
Index: 5_2_2/ext/dom/text.c
===================================================================
--- 5_2_2.orig/ext/dom/text.c
+++ 5_2_2/ext/dom/text.c
@@ -87,7 +87,7 @@ Since: DOM Level 3
 int dom_text_whole_text_read(dom_object *obj, zval **retval TSRMLS_DC)
 {
 	xmlNodePtr node;
-	xmlChar *wholetext;
+	xmlChar *wholetext = NULL;
 
 	node = dom_object_get_node(obj);
 
@@ -96,11 +96,25 @@ int dom_text_whole_text_read(dom_object 
 		return FAILURE;
 	}
 
+	/* Find starting text node */
+	while (node->prev && ((node->prev->type == XML_TEXT_NODE) || (node->prev->type == XML_CDATA_SECTION_NODE))) {
+		node = node->prev;
+	}
+
+	/* concatenate all adjacent text and cdata nodes */
+	while (node && ((node->type == XML_TEXT_NODE) || (node->type == XML_CDATA_SECTION_NODE))) {
+		wholetext = xmlStrcat(wholetext, node->content);
+		node = node->next;
+	}
+
 	ALLOC_ZVAL(*retval);
-	wholetext = xmlNodeListGetString(node->doc, node, 1);
-	ZVAL_STRING(*retval, wholetext, 1);
 
-	xmlFree(wholetext);
+	if (wholetext != NULL) {
+		ZVAL_STRING(*retval, wholetext, 1);
+		xmlFree(wholetext);
+	} else {
+		ZVAL_EMPTY_STRING(*retval);
+	}
 
 	return SUCCESS;
 }
Index: 5_2_2/ext/zlib/zlib_fopen_wrapper.c
===================================================================
--- 5_2_2.orig/ext/zlib/zlib_fopen_wrapper.c
+++ 5_2_2/ext/zlib/zlib_fopen_wrapper.c
@@ -76,7 +76,7 @@ static int php_gziop_close(php_stream *s
 			self->gz_file = NULL;
 		}
 		if (self->stream) {
-			php_stream_free(self->stream, PHP_STREAM_FREE_CLOSE | PHP_STREAM_FREE_PRESERVE_HANDLE);
+			php_stream_close(self->stream);
 			self->stream = NULL;
 		}
 	}
@@ -130,7 +130,7 @@ php_stream *php_stream_gzopen(php_stream
 		int fd;
 
 		if (SUCCESS == php_stream_cast(innerstream, PHP_STREAM_AS_FD, (void **) &fd, REPORT_ERRORS)) {
-			self->gz_file = gzdopen(fd, mode);
+			self->gz_file = gzdopen(dup(fd), mode);
 			self->stream = innerstream;
 			if (self->gz_file)	{
 				stream = php_stream_alloc_rel(&php_stream_gzio_ops, self, 0, mode);
Index: 5_2_2/main/streams/streams.c
===================================================================
--- 5_2_2.orig/main/streams/streams.c
+++ 5_2_2/main/streams/streams.c
@@ -1809,6 +1809,9 @@ PHPAPI php_stream *_php_stream_open_wrap
 			case PHP_STREAM_UNCHANGED:
 				return stream;
 			case PHP_STREAM_RELEASED:
+				if (newstream->orig_path) {
+					pefree(newstream->orig_path, persistent);
+				}
 				newstream->orig_path = pestrdup(path, persistent);
 				return newstream;
 			default:
Index: 5_2_2/Zend/zend_execute_API.c
===================================================================
--- 5_2_2.orig/Zend/zend_execute_API.c
+++ 5_2_2/Zend/zend_execute_API.c
@@ -675,6 +675,10 @@ int zend_call_function(zend_fcall_info *
 		}
 
 		if (fci->object_pp) {
+			if (Z_TYPE_PP(fci->object_pp) == IS_OBJECT
+				&& (!EG(objects_store).object_buckets || !EG(objects_store).object_buckets[Z_OBJ_HANDLE_PP(fci->object_pp)].valid)) {
+				return FAILURE;
+			}
 			/* TBI!! new object handlers */
 			if (Z_TYPE_PP(fci->object_pp) == IS_OBJECT) {
 				if (!IS_ZEND_STD_OBJECT(**fci->object_pp)) {
@@ -839,6 +843,10 @@ int zend_call_function(zend_fcall_info *
 		calling_scope = fci_cache->calling_scope;
 		fci->object_pp = fci_cache->object_pp;
 		EX(object) = fci->object_pp ? *fci->object_pp : NULL;
+		if (fci->object_pp && *fci->object_pp && Z_TYPE_PP(fci->object_pp) == IS_OBJECT
+			&& (!EG(objects_store).object_buckets || !EG(objects_store).object_buckets[Z_OBJ_HANDLE_PP(fci->object_pp)].valid)) {
+			return FAILURE;
+		}
 	}
 
 	if (EX(function_state).function->common.fn_flags & (ZEND_ACC_ABSTRACT|ZEND_ACC_DEPRECATED)) {
Index: 5_2_2/sapi/cgi/fastcgi.c
===================================================================
--- 5_2_2.orig/sapi/cgi/fastcgi.c
+++ 5_2_2/sapi/cgi/fastcgi.c
@@ -255,6 +255,11 @@ int fcgi_is_fastcgi(void)
 	}
 }
 
+void fcgi_shutdown(void)
+{
+	is_fastcgi = 0;
+}
+
 #ifdef _WIN32
 /* Do some black magic with the NT security API.
  * We prepare a DACL (Discretionary Access Control List) so that
Index: 5_2_2/sapi/cgi/fastcgi.h
===================================================================
--- 5_2_2.orig/sapi/cgi/fastcgi.h
+++ 5_2_2/sapi/cgi/fastcgi.h
@@ -112,6 +112,7 @@ typedef struct _fcgi_request {
 } fcgi_request;
 
 int fcgi_init(void);
+void fcgi_shutdown(void);
 int fcgi_is_fastcgi(void);
 int fcgi_in_shutdown(void);
 int fcgi_listen(const char *path, int backlog);
Index: 5_2_2/ext/standard/file.c
===================================================================
--- 5_2_2.orig/ext/standard/file.c
+++ 5_2_2/ext/standard/file.c
@@ -2366,6 +2366,13 @@ PHP_FUNCTION(realpath)
 	convert_to_string_ex(path);
 
 	if (VCWD_REALPATH(Z_STRVAL_PP(path), resolved_path_buff)) {
+		if (PG(safe_mode) && (!php_checkuid(resolved_path_buff, NULL, CHECKUID_CHECK_FILE_AND_DIR))) {
+			RETURN_FALSE;
+		}
+
+		if (php_check_open_basedir(resolved_path_buff TSRMLS_CC)) {
+			RETURN_FALSE;
+		}
 #ifdef ZTS
 		if (VCWD_ACCESS(resolved_path_buff, F_OK)) {
 			RETURN_FALSE;
Index: 5_2_2/win32/build/config.w32
===================================================================
--- 5_2_2.orig/win32/build/config.w32
+++ 5_2_2/win32/build/config.w32
@@ -316,6 +316,8 @@ ADD_SOURCES("regex", "regcomp.c regerror
 
 STDOUT.WriteBlankLines(1);
 
+ARG_ENABLE("memory-limit", "dummy", "no");
+
 /* Can we build with IPv6 support? */
 ARG_ENABLE("ipv6", "Disable IPv6 support (default is turn it on if available)", "yes");
 
Index: 5_2_2/zend-endian-uni.diff
===================================================================
--- /dev/null
+++ 5_2_2/zend-endian-uni.diff
@@ -0,0 +1,57 @@
+Index: Zend/zend_strtod.c
+===================================================================
+RCS file: /repository/ZendEngine2/zend_strtod.c,v
+retrieving revision 1.17.2.2.2.10
+diff -u -p -d -r1.17.2.2.2.10 zend_strtod.c
+--- Zend/zend_strtod.c	26 Apr 2007 23:13:25 -0000	1.17.2.2.2.10
++++ Zend/zend_strtod.c	29 May 2007 13:14:31 -0000
+@@ -135,7 +135,7 @@ typedef unsigned long int uint32_t;
+ # endif
+ #endif
+ 
+-#ifdef WORDS_BIGENDIAN
++#ifdef __BIG_ENDIAN__
+ #define IEEE_BIG_ENDIAN
+ #else
+ #define IEEE_LITTLE_ENDIAN
+Index: ext/date/lib/parse_tz.c
+===================================================================
+RCS file: /repository/php-src/ext/date/lib/parse_tz.c,v
+retrieving revision 1.20.2.6.2.12
+diff -u -p -d -r1.20.2.6.2.12 parse_tz.c
+--- ext/date/lib/parse_tz.c	25 Jan 2007 14:38:45 -0000	1.20.2.6.2.12
++++ ext/date/lib/parse_tz.c	29 May 2007 13:14:31 -0000
+@@ -33,7 +33,7 @@
+ #endif
+ #include "timezonedb.h"
+ 
+-#ifdef WORDS_BIGENDIAN
++#ifdef __BIG_ENDIAN__ 
+ #define timelib_conv_int(l) (l)
+ #else
+ #define timelib_conv_int(l) ((l & 0x000000ff) << 24) + ((l & 0x0000ff00) << 8) + ((l & 0x00ff0000) >> 8) + ((l & 0xff000000) >> 24)
+Index: ext/hash/hash_tiger.c
+===================================================================
+RCS file: /repository/php-src/ext/hash/hash_tiger.c,v
+retrieving revision 1.4.2.4.2.2
+diff -u -p -d -r1.4.2.4.2.2 hash_tiger.c
+--- ext/hash/hash_tiger.c	8 Jan 2007 22:29:25 -0000	1.4.2.4.2.2
++++ ext/hash/hash_tiger.c	29 May 2007 13:14:32 -0000
+@@ -91,7 +91,7 @@
+ #define split_ex(str) \
+ 	x0=str[0]; x1=str[1]; x2=str[2]; x3=str[3]; \
+ 	x4=str[4]; x5=str[5]; x6=str[6]; x7=str[7];
+-#ifdef WORDS_BIGENDIAN
++#ifdef __BIG_ENDIAN__ 
+ #	define split(str) \
+ 	{ \
+ 		int i; \
+@@ -144,7 +144,7 @@ static inline void TigerFinalize(PHP_TIG
+ 		memset(&context->buffer[context->length], 0, 56 - context->length);
+ 	}
+ 
+-#ifndef WORDS_BIGENDIAN	
++#ifndef __BIG_ENDIAN__ 
+ 	memcpy(&context->buffer[56], &context->passed, sizeof(php_hash_uint64));
+ #else
+ 	context->buffer[56] = (unsigned char) (context->passed & 0xff);
